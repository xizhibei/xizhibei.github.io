<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>须臾之学</title>
  
  <subtitle>别瞎想，多走走，多看书</subtitle>
  <link href="https://blog.xizhibei.me/atom.xml" rel="self"/>
  
  <link href="https://blog.xizhibei.me/"/>
  <updated>2021-05-01T15:35:48.469Z</updated>
  <id>https://blog.xizhibei.me/</id>
  
  <author>
    <name>习之北 (@xizhibei)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 时间之 hwclock</title>
    <link href="https://blog.xizhibei.me/2021/05/01/linux-time-hwclock/"/>
    <id>https://blog.xizhibei.me/2021/05/01/linux-time-hwclock/</id>
    <published>2021-05-01T15:30:02.000Z</published>
    <updated>2021-05-01T15:35:48.469Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: linux-time-hwclock --><p>Linux 中，有好些个工具是跟时间相关的，最近工作遇到了它们，于是打算写几篇与 Linux 时间相关的文章。</p><p>今天先说说 <code>hwclock</code> 这个工具，估计也就玩物联网的朋友会用到了，因为这个工具往往只是用来保持硬件设备的时间的，但是前大多数设备往往都是联网的，也就是用的 NTP。</p><p>另外，Ubuntu 15.04 之后就用 <code>systemd</code> 来管理时间了，它里面自带的 <code>timedatectl</code> 工具取代了 <code>hwclock</code>，不过本质上是差不多的内容，这里就不多说了。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>当设备无法联网的时候，RTC 就会变得非常重要，系统的时间将会依靠纽扣电池的能量来维持。如果设备需要经常开关机，那么就会更加依赖 RTC 来保持设备时间的同步。</p><p>它的原理很简单，就是用纽扣电池驱动 RTC（Real-Time Clock）芯片来保持设备断电时候的时间，这样当设备重启的时候，就能直接从 RTC 恢复时间了。</p><p>首先让我们来看看 <code>hwclock</code> 的帮助信息：</p><pre><code>Usage: hwclock [function] [option...]Time clocks utility.Functions: -r, --show           display the RTC time     --get            display drift corrected RTC time     --set            set the RTC according to --date -s, --hctosys        set the system time from the RTC -w, --systohc        set the RTC from the system time     --systz          send timescale configurations to the kernel -a, --adjust         adjust the RTC to account for systematic drift     --predict        predict the drifted RTC time according to --dateOptions: -u, --utc            the RTC timescale is UTC -l, --localtime      the RTC timescale is Local -f, --rtc &lt;file&gt;     use an alternate file to /dev/rtc0     --directisa      use the ISA bus instead of /dev/rtc0 access     --date &lt;time&gt;    date/time input for --set and --predict     --delay &lt;sec&gt;    delay used when set new RTC time     --update-drift   update the RTC drift factor     --noadjfile      do not use /etc/adjtime     --adjfile &lt;file&gt; use an alternate file to /etc/adjtime     --test           dry run; implies --verbose -v, --verbose        display more details -h, --help           display this help -V, --version        display version</code></pre><p>下面来说说，如何使用这个命令来解决我们常见的两个问题。</p><h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><p>首先要分清两个时间，一个是硬件时间，也就是在 RTC 等硬件芯片中的时间，另一个是系统时间，也就是系统内核中的时间。</p><p>为了同步时间，用到它的两个参数就够了：</p><ol><li> 在关机前，将时间从系统写入 RTC：<code>hwclock --systohc</code></li><li> 在开机时，将时间从 RTC 写回系统：<code>hwclock --hctosys</code></li></ol><p>其实这步做完就可以完成离线状态下的时间同步了。设备能够在大多数情况下，达到设备时间保持与真实时间同步。</p><p>但，如果设备的时间精确性很重要，那么你就需要用到它的矫正功能了。</p><h3 id="误差矫正"><a href="#误差矫正" class="headerlink" title="误差矫正"></a>误差矫正</h3><p>其实 RTC 的工作依赖于一块 <code>32.768kHz</code> 的晶振，也就是一块石英晶体，然而，石英晶体是不稳定的，尤其在温度变化的时候，就会变得有误差，这个误差每天可以达到一秒或更多。</p><p><img src="https://blog.xizhibei.me/media/16144968619674/16198584907844.jpg" alt="RTC 受温度影响的误差"></p><p>上图来自<a href="https://www.ti.com/lit/ml/slap107/slap107.pdf">1</a>，可以从图中看到，温度过低或者过高都会导致偏差增大，而我们的设备一般是无法放在一个恒温环境下的，于是每天必然造成误差。</p><p>如何矫正这个误差呢？有硬件方案，也有软件方案。</p><p>硬件方案，德州仪器公司给了一个方案<sup><a href="https://www.ti.com/lit/ml/slap107/slap107.pdf">1</a></sup>，可以直接用温度传感器来补偿 RTC 的精度，由于对硬件这块儿不熟悉，也说不出个所以然，只是明显的，硬件成本会增加一些。</p><p>软件方案就会朴实很多，<strong>因为我们可以假设这个设备所处的环境不变，硬件时间与系统时间的偏差是系统性的，简单点说，就是每隔一段固定的，它们之间时间的偏差其实是一致的</strong><sup><a href="https://man7.org/linux/man-pages/man8/hwclock.8.html">2</a></sup>。于是，我们用软件工程的角度来低成本地校准，也就是 <code>hwclock</code> 的校准功能。</p><p>它会用到一个文件 <code>adjfile</code>，用来记录校准的状态，不过先需要解释下 <code>adjfile</code> 的格式，它默认是 <code>/etc/adjtime</code>，它的内容包含 3 行文本<sup><a href="https://man7.org/linux/man-pages/man5/adjtime.5.html">3</a></sup>：</p><ul><li>第一行，包含三个值：<ul><li>  系统时间每天偏移量（秒）</li><li>  上次调整时间 (Unix 时间戳)</li><li>  校正状态</li></ul></li><li>  第二行：上次校准时间 (Unix 时间戳)</li><li>  第三行：”UTC” 或者 “LOCAL”（一般只会用 UTC，别用 LOCAL 给自己添堵）</li></ul><p>校准的用法也非常简单：</p><p>不过在开始之前，首先你需要确认 Linux 内核没有激活自动同步系统时间到硬件时间，不然会被 NTP 的 <em>11 分钟模式</em> 自动同步<sup><a href="https://man7.org/linux/man-pages/man8/hwclock.8.html">2</a></sup>。具体就是运行 <code>adjtimex --print</code> 或者 <code>adjtimex</code>，看它的 status 值，看看有没有 <code>UNSYNC</code>，有就是不同步，或者需要自己计算下 <code>status &amp; 0x40</code>，为 <code>1</code> 表示不同步<sup><a href="https://man7.org/linux/man-pages/man8/hwclock.8.html">2</a>、<a href="https://github.com/torvalds/linux/blob/9f4ad9e425a1d3b6a34617b8ea226d56a119a717/include/uapi/linux/timex.h">4</a></sup>。</p><ol><li> （如果自动同步是激活状态）关闭且禁用 ntp 后台进程，且不会随系统启动；</li><li> 手动同步一次系统时间;</li><li> 同步系统时间至 RTC：<code>hwclock --systohc</code>，这时候，<code>/etc/adjtime</code> 里面的时间戳将会更新，但是偏移量为 0;</li><li> 关机，等待至少一天；</li><li> 开机，然后马上手动同步一次系统时间，然后让 hwclock 同步到 RTC 的同时，自动计算偏差 <code>hwclock --systohc --update-drift</code>；</li><li> 查看以及确认<code>/etc/adjtime</code> 里面的偏移量；</li><li> （如果自动同步是激活状态）启动且启用 ntp 后台进程</li></ol><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://www.ti.com/lit/ml/slap107/slap107.pdf">Implementing a Temperature Compensated RTC, PDF</a></li><li> <a href="https://man7.org/linux/man-pages/man8/hwclock.8.html">hwclock - time clocks utility</a></li><li> <a href="https://man7.org/linux/man-pages/man5/adjtime.5.html">adjtime - information about hardware clock setting and drift factor</a></li><li> <a href="https://github.com/torvalds/linux/blob/9f4ad9e425a1d3b6a34617b8ea226d56a119a717/include/uapi/linux/timex.h">torvalds/linux:include/uapi/linux/timex.h</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/169">https://github.com/xizhibei/blog/issues/169</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/05/01/linux-time-hwclock/" target="_blank">https://blog.xizhibei.me/2021/05/01/linux-time-hwclock/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: linux-time-hwclock --&gt;

&lt;p&gt;Linux 中，有好些个工具是跟时间相关的，最近工作遇到了它们，于是打算写几篇与 Linux 时间相关的文章。&lt;/p&gt;
&lt;p&gt;今天先说说 &lt;code&gt;hwclock&lt;/code&gt; 这个工具，估计也</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.xizhibei.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>不拘一格的网飞</title>
    <link href="https://blog.xizhibei.me/2021/03/28/netflix-no-rules-rules/"/>
    <id>https://blog.xizhibei.me/2021/03/28/netflix-no-rules-rules/</id>
    <published>2021-03-28T07:56:14.000Z</published>
    <updated>2021-05-01T15:35:48.469Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: netflix-no-rules-rules --><p>对于网飞的文化，我向来推崇备至，在之前的多篇文章里面，也提到过很多次：</p><ol><li> <a href="https://blog.xizhibei.me/2017/07/09/cong-ba--sla--jia-jin--kpi--kao-he-shuo-qi/">从把 SLA 加进 KPI 考核说起</a></li><li> <a href="https://blog.xizhibei.me/2018/05/06/lets-talk-about-the-service-stability/">谈谈服务稳定性</a></li><li> <a href="https://blog.xizhibei.me/2019/05/20/how-to-fail-black-box-thinking/">如何理性地失败：黑匣子思维</a></li></ol><p>这次见到这本网飞 CEO 里德 · 哈斯廷斯写的书出来后，也是第一时间排上了阅读计划。这几天看完之后，有种难以名状的感受：就像自己被自己打了脸。</p><p>以下涉及剧透，慎读。</p><h3 id="自由与责任工作法"><a href="#自由与责任工作法" class="headerlink" title="自由与责任工作法"></a>自由与责任工作法</h3><p>整本书的逻辑很简单：给市场最高的薪水，雇佣最牛的人才，提高人才密度，然后给他们最自由的环境、坦诚的职场关系、透明的信息以及充分的授权，然后让他们以公司的利益为上来自由地做最好的决定。同时，在公司内部实行与薪酬福利无关的 360 度反馈，以 4A 原则（下面会提到）来不断复盘反省提升，从而变得更加优秀，并且公司持续按市场最高薪水来调整他们的薪酬，但是一旦发现不合适就会让他们走人。通过这种方式不断提升人才密度，做到行业最佳。</p><p>接下来，我来说说让我感受比较深的几个点，虽然有些观点在《奈飞文化手册》也是看到过的，如今再看一遍仍然觉得有些内容反直觉、反传统。</p><h4 id="取消限期休假制度、取消差旅和经费审批"><a href="#取消限期休假制度、取消差旅和经费审批" class="headerlink" title="取消限期休假制度、取消差旅和经费审批"></a>取消限期休假制度、取消差旅和经费审批</h4><p>虽然刚听起来，有点耸人听闻，只是细想起来，这也会比较容易理解，在一个人人都是透明坦诚的公司里面，但凡自己做点什么有害公司利益的事情，就会被大家瞧不起，因为在这个人才密度非常高的公司里面，大家都在以公司的利益而努力奋斗。</p><p>或许你会担心，一旦给了那么高的自由度，员工滥用了怎么办，网飞是这样做的：严厉惩罚，但是依然保持这个制度。因为他们清楚，保持这种情况，会比束缚员工的自由的代价小很多。</p><p>不过这个制度有一个最大的前提，那就是<strong>足够高的人才密度</strong>，另外还有老板的胸襟以及开放透明的公司文化。</p><blockquote><p>企业拥有一支高绩效的团队，员工才会认真负责地工作；企业拥有坦诚的文化氛围，员工才会互相监督，共同维护公司利益。在此前提下，企业可以放松对员工的管控，给予他们更多的自由。</p></blockquote><p>这也让我想起了<a href="https://blog.xizhibei.me/2019/02/11/a-mighty-river-flows-eastward/">《大江东去》</a>中，我们国家经济发展过程中的对待民营企业的态度。杨巡可以说就是我们国家民营经济的代表人物了，他是拼尽全力才能在这个激烈异常的环境中存活下来，一开始是不被国家承认的资本主义小商小贩，非得挂靠在雷东宝的集体企业中才有资格卖货，之后遇到了改革开放才成为有资格注册的个体户，期间也是多次游走于灰色地带「不守规矩」才没有被淘汰，如今太多的民营企业家多少都会有杨巡的影子，都是靠自己的双手拼命打拼才取得如今的成果，如果你让杨巡在他的企业中学习网飞的自由环境，恐怕他只会把你当成骗子轰出大门。</p><p>其实我想说的是，我们国家的企业与国外的企业，整体上还是有发展的差距，这种优秀的企业是只有国家发展到一定程度才会出现的产物，我们学习优秀的思想也不能只看表面，学个皮毛，也就是说可以借鉴却不能照抄。我不相信能带给企业发展前景的先进制度，企业家们不会去考虑。正如目前一直在讨论的 996 问题，迟迟没有个结果的原因何在？很简单，我们想要的薪酬福利，只有 996 的公司能给，我们没得选。其实更多是我们国家自身的发展问题，或者说，只是时机未到。</p><p>另外，据说国内企业中，字节跳动目前的文化是最像网飞的，我相信这种企业会越来越多的。</p><h4 id="支付行业最高薪酬，取消绩效奖金以及股权激励"><a href="#支付行业最高薪酬，取消绩效奖金以及股权激励" class="headerlink" title="支付行业最高薪酬，取消绩效奖金以及股权激励"></a>支付行业最高薪酬，取消绩效奖金以及股权激励</h4><p>或许支付行业最高薪酬能够理解，但是取消绩效奖金确实很难让现阶段的我们来理解了，只是，网飞的理由却很充分。</p><p>他们不想靠奖金来激励员工，<strong>奖金会让员工只专注于目标，而不是考虑什么才是对公司真正有利的。</strong></p><p>相比于专注目标，他们更在意的是员工的创造性，他们不想让员工因为奖金的多少来妨碍创新，因为真正有积极性的员工不会因为奖金多了就更加努力，奖金少了就松懈下来。</p><blockquote><p>创造性工作要求在一定程度上解放你的大脑。如果你总想着要怎么做才能表现好，才能得到高额的奖金，那么你就缺少开放的认知空间，产生最好的想法和最好创意的可能性也微乎其微。结果，你反倒做得更差。</p><p>在我们用足够高的工资帮助员工减轻家庭负担之后，他们最具创造力。但是如果他们并不确定自己能否得到额外的报酬，创造力就会下降。由此可见，有利于激发创造力的，是足够高的工资，而非绩效奖金。</p><p>不实行绩效奖金，提供更高的基本工资，留住工作积极性高的员工，这些做法都可以增加人才密度。但增加人才密度最有效的办法，是一开始就支付给员工高薪，并且随着时间的推移不断上涨，以此保证他们始终获得市场上最高的工资。</p></blockquote><p>对于取消奖金的做法，我也是比较认同的，相比于完成挑战自己的任务以及做出优秀的成绩所带来的成就感，奖金带来的激励很大程度上就是饮鸩止渴。</p><h4 id="仅仅做到称职也要拿钱走人"><a href="#仅仅做到称职也要拿钱走人" class="headerlink" title="仅仅做到称职也要拿钱走人"></a>仅仅做到称职也要拿钱走人</h4><p>这一点怕是有老板看了就深信不疑的一个观点，于是号召大家学习这一点，并扬言 “混日子的人不是我的兄弟”，于是实行末位淘汰都会显得顺理成章。</p><p>或许他们做的没问题，关键的地方在于，他们只想像网飞一样提高人才密度，却不想为之付出努力与成本，说人话就是不想给补偿。</p><p>网飞的这个做法，即即使员工足够努力，也做出了共享，但是如果没做到跟进公司的创新步伐也要拿钱走人。这点即使是在硅谷也是非常引争议的，事实却证明，结果没有那么坏，因为他们的离职率没有想象中的高，结果也比想象中好太多，他们做出的成果是大家有目共睹的，网飞的电视剧质量越来越高也是一个我们能感受到的侧面例子。</p><p>至于网飞如何防止这种淘汰方法妨碍员工的创新能力以及互相协作，很简单，他们做的事情不是末位淘汰。他们在公司内部，营造足够坦诚的文化。所有员工都知道为什么自己会被淘汰，以及通过「员工留任提示」来与领导沟通，获取反馈。并且，员工也能通过被解雇员工的「离职后问答」，知道被解雇的原因，从而消除自己心中的不安。</p><p>员工留任提示，也就是鼓励员工与上级进行一对一沟通：</p><blockquote><p>“如果我想要辞职，你会花多大力气劝我改变主意？”</p></blockquote><h4 id="坦诚沟通和正面有效反馈"><a href="#坦诚沟通和正面有效反馈" class="headerlink" title="坦诚沟通和正面有效反馈"></a>坦诚沟通和正面有效反馈</h4><p>人才密度提高后，要使人才真正发挥作用，就需坦诚以及正面有效反馈。</p><p>很遗憾的是，在我们目前的社会中，互相信任的关系还是很少的，我还没有遇到过非常坦诚的公司，因为他们从谈薪酬开始就不会对你坦诚，更不用说进入公司后，公司就会用劳动合同以及种种的条条框框来限制你的行动，从这点来说，我更喜欢小公司：限制少，创新能力强。</p><p>所谓正面有效反馈，就是上面说的 4A 原则：</p><blockquote><ul><li>  目的在于帮助：反馈者应清晰阐述这样做对他人和公司有什么样的好处。</li><li>  反馈应具有可行性：你的反馈必须说明接收人可以做一些什么样的改变。</li><li>  感激与赞赏：我们在收到批评时都会为自己辩护或找借口，这是人类的本能。在接收反馈时，你需要有意识地反抗这种本能。</li><li>  接受或拒绝：不是每条反馈都要求你照搬，但有必要向反馈者真诚地致谢。你和反馈者必须清楚：对反馈意见的处理完全取决于反馈的接收者。</li></ul></blockquote><p>360 度反馈是个非常有用的工具，奈何大部分使用这种工具的公司都把 360 度的结果与绩效考核挂钩，生生的把它变成了 KPI 工具。网飞如何使用它就是个非常有用的例子：它是用来获取身边人的正面有效反馈的。</p><blockquote><p>360 度公开反馈引发了一系列有价值的讨论。我与直系下属系统地分享我收到的意见，我的下属又与他们的团队分享他们得到的反馈，层层分享，依此类推。这不仅可以增强公司内部的透明度，也形成了一种 “反向负责制”，即员工从中受到鼓励，能够对上级多次出现的问题进行大胆的反馈。</p></blockquote><p>这种互相坦诚的做法值得每个人学习，虽然暂时会对自己不利，只是心底无私天地宽，路自然会越走越宽。</p><h4 id="情景管理而非控制管理"><a href="#情景管理而非控制管理" class="headerlink" title="情景管理而非控制管理"></a>情景管理而非控制管理</h4><p>我对这个观点印象非常深刻，因为书中举了个很形象的例子：</p><p>当你的孩子要去参加一个聚会的时候，你作为家长会怎么做呢？</p><p>如果你告诉孩子什么不可做，什么可以做，并且要孩子把所有相关的信息告诉你，之后你还要偷偷跟着孩子去监视他，这就是控制管理。</p><p>而如果你是告诉孩子，什么不可以做，并且还通过一些辅助手段（一起看书、看教育片等）教育孩子为什么不可以做，事后也只是让孩子事后有问题马上联系自己，这就是情景管理。</p><p>想必大家看了也会明白，也就是所谓的少限制，多放权，<strong>少微观管理，多宏观管理</strong>。相比于事无巨细地告诉他们目标在哪、如何达到目标，激起他们对目标的渴望更重要。</p><p>现实中，大部分公司都是金字塔形的结构，即所有的重大决策都需要层层上报，但是能做决定的领导往往不是那个适合做决定的，因为这不是所谓的 “让听得见炮声的人来做决策 “（没想到吧，这句话是华为老总任正非说的）。网飞的这种所谓的树形结构，让处于树根的领导层专注于真正的战略层面，而把具体事务的决策权下放到处于各个树枝的负责人手里。</p><blockquote><p>如果想要公司在松散耦合的体制中高效运转，让员工个人也能做出重大决策，那么老板和员工必须就他们的目标达成一致。只有领导和员工认识清晰，目标一致，松散耦合的体制才能发挥作用。这种一致性能够驱动员工做出决策，以完成整个组织的使命和战略任务。</p></blockquote><p>这种方法论，其实国内的企业家都明白，而且很多优秀的企业也在内部实行了，一如华为。而这其中的原理，明白一点软件架构的技术人也能看出来：高内聚低耦合的架构能应付多变的业务场景，方便调整，非常高效以及灵活。放到企业组织架构中也一样，对于任何一个处于创新引导的产业中的公司，这种架构能够更有效的应对未知的市场，从而取得成功。</p><p>至于另外提到的目标是创新而不是防范错误，我已经在文章开头的几篇中多次提到，不再赘述。</p><h3 id="回过头来看网飞的企业文化"><a href="#回过头来看网飞的企业文化" class="headerlink" title="回过头来看网飞的企业文化"></a>回过头来看网飞的企业文化</h3><p>其实整本书说的都是围绕这<strong>自由与责任</strong>这两个词来说的，什么是自由与责任以及如何做到自由与责任。</p><p>随着职场经验的累积，我发现自己不像从前那么强调网飞多么优秀了，因为我发现从前的自己强调的更多是自由，而不是与之相生相伴的责任，或者说，我也更理解老板们的苦衷了。虽然他们看了这本书之后，还是会认为不可能做到网飞的程度，甚至是跟以前只学华为的狼性却不学华为给员工大块肉，现在可能只想学网飞开除不称职的员工，却不想给员工遣散费。</p><p>回过头来，我才认识到自己一直是那个只见树木不见树林的人。自己一直认为是众人皆醉我独醒，可结果是小丑竟是我自己。网飞的文化终究是属于网飞自己的，但是企业优秀并不代表文化就一定优秀，可以借鉴，但不可照抄。</p><p>至于那么好的文化，有没有可能被国内公司或者自己所在的公司学到精髓我不清楚，对于我自己而言，做到配得上网飞文化，还是可以努力的：<a href="https://blog.xizhibei.me/2020/05/04/poor-charlies-almanack-a-rich-and-wisdom-old-man-Charles-T-Munger/">让自己得到一件东西的最好方式，就是让自己配得上它</a>。</p><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/166">https://github.com/xizhibei/blog/issues/166</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/03/28/netflix-no-rules-rules/" target="_blank">https://blog.xizhibei.me/2021/03/28/netflix-no-rules-rules/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: netflix-no-rules-rules --&gt;

&lt;p&gt;对于网飞的文化，我向来推崇备至，在之前的多篇文章里面，也提到过很多次：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; &lt;a href=&quot;https://blog.xizhibei.me/2017/07/09</summary>
      
    
    
    
    
    <category term="企业文化" scheme="https://blog.xizhibei.me/tags/%E4%BC%81%E4%B8%9A%E6%96%87%E5%8C%96/"/>
    
    <category term="职场" scheme="https://blog.xizhibei.me/tags/%E8%81%8C%E5%9C%BA/"/>
    
    <category term="鉴书" scheme="https://blog.xizhibei.me/tags/%E9%89%B4%E4%B9%A6/"/>
    
    <category term="读书" scheme="https://blog.xizhibei.me/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>工程师的傲骄</title>
    <link href="https://blog.xizhibei.me/2021/03/22/engineer-s-tsundere/"/>
    <id>https://blog.xizhibei.me/2021/03/22/engineer-s-tsundere/</id>
    <published>2021-03-22T12:52:52.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: engineer-s-tsundere --><p>最近的几场外部对接，由于我们的业务涉及到对外合作，因此避免不了跟外部工程师的对接，然而对接的时候，就是出现各种幺蛾子的时候了。但是，这个过程中，让我发现了一个很有意思的事情：在群里吵起来的两个工程师，私下聊天的时候却是和和气气的。</p><p>我们从典型的外部对接开始说起。</p><h3 id="典型的外部对接"><a href="#典型的外部对接" class="headerlink" title="典型的外部对接"></a>典型的外部对接</h3><p>大致的流程是这样的：销售跟商务接触合作方，双方互相了解需求，如果合适的话，就开始商讨各自去哭，确定如何进行商务上的对接，同时，这时候看双方的合作意愿情况，来决定谁是大爷，谁是孙子。至于判断谁是大爷，从我一个工程师的角度来说，那就是国企 / 央企 &gt; 有政府关系的私企 &gt; 大企业 &gt; 小企业。相信你快看就能看出来，其实就是按资源的掌控程度来决定的。</p><p>所以，基本上大爷就只需要提供 API 文档，技术文档就可以了，这些文档会被商务转发到工程师手里，进行初步的技术判断，看看对方的文档能不能提供己方的需求。</p><p>当大家基本确定需求了，一起进一个群，同时把双方的工程师拉进群里，这时候，问题就出现了，有些商务比较没概念，直接把没有事先通知详细情况的工程师拉进群，就会导致奇葩情况出现。</p><p>首先大家互相介绍，之后对方在群里扔了一个文档，然后己方的商务直接艾特你，于是你很懵地看了看文档，大致明白了对方让你对接。然后问题就来了，如果你这时候说对方的 API 文档不满足需求，甚至提出了修改意见，那对方就会非常傲慢地跟你说：</p><p>“其他家都是这样对接的，他们没有问题，怎么就你有问题？“” 你这方案不行，我们不可能为你们专门修改系统的，修改了其他客户怎么办？“<br>“你们的实施成本高，那是你们需要解决的问题，这跟我们没有关系。“</p><p>这时候，你只能憋着一肚子火，简单回一个：” 好的，明白了 “。</p><p>以为到这个时候，事情就完事了吗？显然不会。因为后续的流程都必须按照他们的流程走，而这个流程会让你非常痛苦，这不是接口对接了就完成的事情，因为你的公司可能才是卖产品给用户的人，后续一旦有问题，客户肯定第一个找的就是你，如对接服务总是出问题，不稳定，接口出错，于是你必须抽时间来解决这些问题，再次跟他们确认问题所在，帮对接方查找问题。</p><p>一旦查到了问题所在，你会发现这时候火药味很可能会很浓，因为出错的一方注定会被「鄙视」。其实不用偷笑，就算作为当事人的你，在心里多少会对对方有想法的。</p><h3 id="一个反转"><a href="#一个反转" class="headerlink" title="一个反转"></a>一个反转</h3><p>看到这里，或许你会认为对方真傲慢，是个不讲理的人。</p><p>然而如果你加了对方好友，你就会发现聊天的时候，对方完全变了个样。在群里的时候，他不会那么好说话，甚至会跟你针锋相对。但是一旦到了私下，你会发现对方可能比较好说话，有什么问题也会第一时间给你解答，帮你解决问题所在。</p><p>为什么呢？</p><p>显然，群是在一个公开的地方，商务销售甚至顶头上司也在，那他所有的话都会变的非常正式，态度强硬，不会让你觉得非常好讲话。但是私下聊天，没有了群里的压力，同为技术人员，但凡有点胸襟，大家都会互相学习，有一种同为打工人，都不容易，互相帮忙的意思。</p><h3 id="另一个反转"><a href="#另一个反转" class="headerlink" title="另一个反转"></a>另一个反转</h3><p>或许你会认为我在与外部对接中是个比较好说话的人，那你又错了。</p><p>因为我们公司也有当大爷的时候，而事后才发现，我居然也会非常傲慢。比如一旦对方说看不懂我写的文档，或者不会搭建一些基础服务的时候，我就会认为对方水平不行，懒得理睬。当同事在私下提醒我，说话的时候不要那么冲的时候，才明白自己给对方留下了不好的印象。</p><p>关键，我们还不是国企央企之类的，是个小微企业，那就意味着我还不得不给他们解答，为他们修改方案。</p><p>这个问题不仅仅发生在我身上，我的同事也会如此。在群里吵架的我也见到过不少，然而那个吵得很凶的同事，现实中却是一个与我们相处很愉快的人。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>有对接经历的朋友，相信会有类似的体会，明明是挺好相处的一个人，却要在外部对接中，显得那么强硬，我把这种现象叫做「工程师的傲娇」。至于背后的原因，其实很大程度上是自尊心，无法放低自己的姿态。</p><p>一旦明白了这其中的缘由，其实就可以进一步反思自己了，有必要跟同为工程师的对方较劲？放低姿态，理解对方，我们才会离成功更进一步。</p><p>我也是慢慢体会到：<strong>不要把对接的另一方同行当作同行，而因该当作你的用户，你应该服务好的用户</strong>。于是，你会认为用户他不会使用你的产品吗？或者你会认为用户水平不行，不够格使用你的产品？或许是的确不会用，但更重要的是你没有让他们觉得很好用，假如真这样的话，你就会失去用户，而一旦把对方当作你的用户，心里平和的你，也会更愿意接受对方的意见，更加理解你的用户，从而改进自己产品。</p><p>我们也不妨把这个思想推广一下：假如你要做公司内部的产品，比如监控，也需要考虑一点：你的监控不仅仅是为你自己服务的，<strong>把你的同事当作用户</strong>，不要用无穷的监控报警去轰炸他们，考虑下用更好的方案，比如 <a href="https://github.com/xizhibei/blog/issues/54">Prometheus 以及 Alert Manager</a> 。</p><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/165">https://github.com/xizhibei/blog/issues/165</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/03/22/engineer-s-tsundere/" target="_blank">https://blog.xizhibei.me/2021/03/22/engineer-s-tsundere/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: engineer-s-tsundere --&gt;

&lt;p&gt;最近的几场外部对接，由于我们的业务涉及到对外合作，因此避免不了跟外部工程师的对接，然而对接的时候，就是出现各种幺蛾子的时候了。但是，这个过程中，让我发现了一个很有意思的事情：在群里吵起来的两个工</summary>
      
    
    
    
    
    <category term="总结" scheme="https://blog.xizhibei.me/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="工作方法" scheme="https://blog.xizhibei.me/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    
    <category term="创业" scheme="https://blog.xizhibei.me/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>CMake 动态链接库绝对路径问题</title>
    <link href="https://blog.xizhibei.me/2021/02/12/cmake-shared-lib-absolute-path-problem/"/>
    <id>https://blog.xizhibei.me/2021/02/12/cmake-shared-lib-absolute-path-problem/</id>
    <published>2021-02-12T08:48:46.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: cmake-shared-lib-absolute-path-problem --><p>今天这篇文章算是对 <a href="https://blog.xizhibei.me/2020/04/20/cmake-5-install-package-and-export/">【CMake 系列】（五）安装、打包与导出</a> 的一个补充。其实我本打算跟上篇文章放在一起，毕竟都属于动态链接库相关的知识，但是这样一来就不容易被出现问题的同学们检索到了（才不是为了再水一篇文章 doge）。</p><h3 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h3><p>是因为这个问题困扰了我不少时间，在好几个项目里面都遇到了这个问题。</p><p>那就是链接动态库的时候，编译出来的可执行文件会带有编译时的绝对路径，于是你将程序拷贝到其它地方运行的时候，必须把动态库放到绝对路径里面去，而不是放在系统里面相关的 lib 路径下面。</p><p>举一个例子，假如我们要实现一个 <code>FooConfig.cmake</code>，这个库中既有静态库也有动态库，那么如果我们要在项目中使用，大概的实现方式是：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_path</span>(FOO_INCLUDE_DIRS NAMES foo.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">get_filename_component</span>(_IMPORT_PREFIX <span class="string">&quot;$&#123;FOO_INCLUDE_DIRS&#125;&quot;</span> PATH)</span><br><span class="line"><span class="keyword">set</span>(FOO_LIBRARY_DIRS <span class="variable">$&#123;_IMPORT_PREFIX&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> FOO_FIND_COMPONENTS)</span><br><span class="line">  <span class="keyword">set</span>(FOO_FIND_COMPONENTS foo bar)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FOO_USE_SHARED <span class="number">1</span>)</span><br><span class="line"><span class="keyword">set</span>(_CMAKE_FIND_LIBRARY_SUFFIXES <span class="variable">$&#123;CMAKE_FIND_LIBRARY_SUFFIXES&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(FOO_USE_SHARED)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_FIND_LIBRARY_SUFFIXES .so)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_FIND_LIBRARY_SUFFIXES .a)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(lib <span class="variable">$&#123;FOO_FIND_COMPONENTS&#125;</span>)</span><br><span class="line">  <span class="keyword">set</span>(_lib_location <span class="string">&quot;_lib_location-NOTFOUND&quot;</span>)</span><br><span class="line">  <span class="keyword">find_library</span>(_lib_location NAMES <span class="string">&quot;$&#123;lib&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> _lib_location)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;FOO lib &#x27;$&#123;lib&#125;&#x27; is not found&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(_lib_name FOO::<span class="variable">$&#123;lib&#125;</span>)</span><br><span class="line">  <span class="keyword">add_library</span>(<span class="variable">$&#123;_lib_name&#125;</span> UNKNWON IMPORTED)</span><br><span class="line">  <span class="keyword">set_target_properties</span>(</span><br><span class="line">    <span class="variable">$&#123;_lib_name&#125;</span></span><br><span class="line">    PROPERTIES INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;FOO_INCLUDE_DIRS&#125;&quot;</span></span><br><span class="line">               IMPORTED_LOCATION_RELEASE <span class="string">&quot;$&#123;_lib_location&#125;&quot;</span></span><br><span class="line">               IMPORTED_CONFIGURATIONS RELEASE)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">list</span>(APPEND FOO_LIBS <span class="string">&quot;$&#123;_lib_name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unset</span>(_lib_location) <span class="comment"># clean</span></span><br><span class="line">  <span class="keyword">unset</span>(_lib_name) <span class="comment"># clean</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_LIBRARY_SUFFIXES <span class="variable">$&#123;_CMAKE_FIND_LIBRARY_SUFFIXES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FindPackageHandleStandardArgs)</span><br><span class="line">find_package_handle_standard_args(Reader REQUIRED_VARS FOO_INCLUDE_DIRS</span><br><span class="line">                                                       FOO_LIBS)</span><br><span class="line"></span><br><span class="line"><span class="keyword">mark_as_advanced</span>(FOO_INCLUDE_DIRS FOO_LIBS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cleanup</span></span><br><span class="line"><span class="keyword">unset</span>(_IMPORT_PREFIX)</span><br><span class="line"><span class="keyword">unset</span>(_CMAKE_FIND_LIBRARY_SUFFIXES)</span><br></pre></td></tr></table></figure><p>将它命名为 <code>FooConfig.cmake</code> 然后放在位于项目根目录的 cmake 文件夹下，并且在项目中这样使用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Foo REQUIRED HINTS <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PRIVATE <span class="variable">$&#123;FOO_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>最后，假如我们查找的库在 <code>/path/to/foo/home</code> 下面，那么我们用在项目中得到的结果会是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d a.out | grep NEEDED</span><br><span class="line">Dynamic section at offset 0xb5ddb4 contains 2 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [/path/to/foo/home/lib/libfoo.so]</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [/path/to/foo/home/lib/libbar.so]</span><br></pre></td></tr></table></figure><p>这里就出现了绝对路径，当初这个问题折磨了我很久，一直以为是 RPATH 的问题，最后发现是 CMake 本身的问题。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>出现这个问题的原因就是库的 Package Find Config 不对，我研究了挺长时间，最后在官方的<a href="https://gitlab.kitware.com/cmake/cmake/-/issues/18052">讨论</a>中找到了原因以及答案：</p><ol><li> 缺少了 <code>IMPORTED_NO_SONAM</code>E 的属性；</li><li> 引入动态库的时候，使用了 <code>UNKNWON</code> 类型的库；</li></ol><p>于是，将上面的代码改下即可：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(FOO_USE_SHARED)</span><br><span class="line">  <span class="keyword">set</span>(FOO_LIB_TYPE <span class="string">&quot;SHARED&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_FIND_LIBRARY_SUFFIXES .so)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(FOO_LIB_TYPE <span class="string">&quot;STATIC&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_FIND_LIBRARY_SUFFIXES .a)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(</span><br><span class="line">    <span class="variable">$&#123;_lib_name&#125;</span></span><br><span class="line">    PROPERTIES INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;FOO_INCLUDE_DIRS&#125;&quot;</span></span><br><span class="line">               IMPORTED_NO_SONAME_RELEASE <span class="keyword">true</span></span><br><span class="line">               IMPORTED_LOCATION_RELEASE <span class="string">&quot;$&#123;_lib_location&#125;&quot;</span></span><br><span class="line">               IMPORTED_CONFIGURATIONS RELEASE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/162">https://github.com/xizhibei/blog/issues/162</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/02/12/cmake-shared-lib-absolute-path-problem/" target="_blank">https://blog.xizhibei.me/2021/02/12/cmake-shared-lib-absolute-path-problem/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: cmake-shared-lib-absolute-path-problem --&gt;

&lt;p&gt;今天这篇文章算是对 &lt;a href=&quot;https://blog.xizhibei.me/2020/04/20/cmake-5-install-package</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://blog.xizhibei.me/tags/C-C/"/>
    
    <category term="CMake" scheme="https://blog.xizhibei.me/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>RPATH 简介以及 CMake 中的处理</title>
    <link href="https://blog.xizhibei.me/2021/02/12/a-brief-intro-of-rpath/"/>
    <id>https://blog.xizhibei.me/2021/02/12/a-brief-intro-of-rpath/</id>
    <published>2021-02-12T08:37:45.000Z</published>
    <updated>2021-05-01T15:35:48.461Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: a-brief-intro-of-rpath --><p>所谓的 RPATH，就是硬编码在可执行文件或者动态库中的一个或多个路径，被动态链接加载器用来搜索依赖库。<sup><a href="https://en.wikipedia.org/wiki/Rpath">1</a></sup></p><p>这个值是存在可执行文件或者动态库的 ELF 结构中的 <code>.dynamic</code> 小节中，它可以用 readelf 或者 objdump 查看。</p><p>具体就是 <code>readelf -d a.out | grep RPATH</code> 或者 <code>objdump -x a.out | grep RPATH</code>。</p><h3 id="Linux-中的动态链接加载器搜索路径"><a href="#Linux-中的动态链接加载器搜索路径" class="headerlink" title="Linux 中的动态链接加载器搜索路径"></a>Linux 中的动态链接加载器搜索路径</h3><p>至于搜索路径，除了 RPATH，链接加载器在 Linux 中，还会有另外几个关键的路径，他们的搜索顺序如下：<sup><a href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling">2</a></sup></p><ul><li>  <strong>LD_LIBRARY_PATH</strong>：环境变量，也是一个或多个路径；</li><li>  <strong>RUNPATH</strong>：与 <strong>RPATH</strong> 一样，但是搜索顺序在 <strong>LD_LIBRARY_PATH</strong> 后面，只在比较新的系统中被支持；</li><li>  <strong>/etc/ld.so.conf</strong>：即链接加载器的配置文件；</li><li>  内置的路径，比如 /lib 以及 /usr/lib；</li></ul><p>至于为何需要那么多的可配置方式，就在于不同的程序会有不同的需求，比如对于不同版本库的需求，就需要单独设置 <strong>RPATH</strong>，用来指定依赖库的位置，而不是使用系统相关的 <strong>LD_LIBRARY_PATH</strong>，因为这个环境变量可能会破坏其它程序的运行。</p><p>下面来说说 CMake 中的 RPATH。</p><h3 id="CMake-中的-RPATH"><a href="#CMake-中的-RPATH" class="headerlink" title="CMake 中的 RPATH"></a>CMake 中的 RPATH</h3><p>跟 RPATH 相关的设置有如下几个（MacOS 相关的今天按下不表）：</p><ul><li>  BUILD_RPATH (version&gt;=3.8)：编译时的 RPATH，在你想要从编译目录中运行程序可能会需要；</li><li>  INSTALL_RPATH：安装时的 RPATH，在你想要从安装目录中运行程序可能会需要；</li><li>  SKIP_BUILD_RPATH：跳过编译时的 RPATH 配置；</li><li>  BUILD_WITH_INSTALL_RPATH：在编译时使用安装时的 RPATH 配置，安装目录与编译目录的依赖路径一致时使用；</li><li>  INSTALL_RPATH_USE_LINK_PATH：将链接时的 RPATH 配置用作安装时的 RPATH，安装目录与链接的依赖路径一致时使用；</li><li>  BUILD_RPATH_USE_ORIGIN (version&gt;=3.14)：是否在编译时使用 <code>$ORIGIN</code>，相对路径；</li><li>  INSTALL_REMOVE_ENVIRONMENT_RPATH (version&gt;=3.16)：安装时是否移除工具链相关的 RPATH；</li></ul><p>这些设置，可以使用 <code>set_target_properties</code> 单独设置在 target 上，也可以在加上 <code>CMAKE_</code> 前缀后，设置成全局配置。至于如何使用，完全取决于你想要如何运行你的程序，比如从编译目录中或者安装目录中运行，可能就需要完全不同的配置。</p><p>其实在大多数场景下，我们都不需要设置这些东西，因为一旦设置了 RPATH，很可能会<strong>不方便移植</strong>，但是如果你需要单独的依赖库路径的时候，这些东西就需要了。</p><p>而如果你真的需要 RPATH，建议的做法是 <strong>使用相对路径，这样就会更容易移植到不同的机器上</strong>，比如 Linux 系统中，可以使用 <code>$origin</code>。<sup><a href="https://cmake.org/pipermail/cmake/2008-January/019290.html">3</a></sup></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$origin/../lib&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://en.wikipedia.org/wiki/Rpath">wikipedia - Rpath</a></li><li> <a href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling">CMake/RPATH-handling</a></li><li> <a href="https://cmake.org/pipermail/cmake/2008-January/019290.html">RPATH and $ORIGIN</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/161">https://github.com/xizhibei/blog/issues/161</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/02/12/a-brief-intro-of-rpath/" target="_blank">https://blog.xizhibei.me/2021/02/12/a-brief-intro-of-rpath/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: a-brief-intro-of-rpath --&gt;

&lt;p&gt;所谓的 RPATH，就是硬编码在可执行文件或者动态库中的一个或多个路径，被动态链接加载器用来搜索依赖库。&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wik</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://blog.xizhibei.me/tags/C-C/"/>
    
    <category term="CMake" scheme="https://blog.xizhibei.me/tags/CMake/"/>
    
    <category term="Linux" scheme="https://blog.xizhibei.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 双向证书认证</title>
    <link href="https://blog.xizhibei.me/2021/02/03/https-two-way-authentication-with-certificates/"/>
    <id>https://blog.xizhibei.me/2021/02/03/https-two-way-authentication-with-certificates/</id>
    <published>2021-02-03T09:51:26.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: https-two-way-authentication-with-certificates --><p>在很久之前，我在 <a href="https://blog.xizhibei.me/2018/07/29/https-and-ssl-tls-review/">划一划 HTTPS 以及 SSL/TLS 的重要知识点</a> 提到过客户端 HTTPS 证书，之后就没后续了，不过目前还是遇到了接口问题，不得不用上了。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>接下来会给大家说清几个概念：HTTPS 单向认证、HTTPS 双向认证、中间人攻击。</p><h4 id="HTTPS-单向认证与双向认证"><a href="#HTTPS-单向认证与双向认证" class="headerlink" title="HTTPS 单向认证与双向认证"></a>HTTPS 单向认证与双向认证</h4><p>在这两种认证场景中，主要的区别在于服务器是不是需要客户端提供证书验证，我们，在进行 TCP 三次握手成功后，就开始进行 SSL 阶段的握手了了。</p><p>SSL 握手阶段可以参考如下，此图盗自 <a href="https://commons.wikimedia.org/wiki/File:Ssl_handshake_with_two_way_authentication_with_certificates.png">Ssl handshake with two way authentication with certificates</a> 。这张图里面的大致阶段是对的，只是并不是很详细，更详细的请参考 <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake">Transport Layer Security</a> 。</p><p><img src="https://blog.xizhibei.me/media/16120752577354/16121774495273.jpg" alt="Ssl handshake with two way authentication with certificates"></p><p>正如如上图所示，这个过程中，主要区别就在于第三阶段<sup><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake">1</a></sup>：</p><ul><li>  第一阶段：协商，客户端发送 hello 消息，会包含自己能支持的最大支持的 TLS 版本，<strong>一个随机数</strong>，以及一系列建议的加密套件以及压缩方法；然后服务器在接收之后，也会发送 hello 消息，包含着根据客户端挑选过的 TLS 版本，加密套件以及压缩方法；</li><li>  第二阶段：服务器证书处理，服务器会将证书发送至客户端，并且紧接着就会发送一个要求发送客户端证书的请求，客户端会在这个时间根据 CA 来验证服务器的证书；</li><li>  第三阶段：客户端证书处理，客户端会将证书发送至服务器，服务器会根据 CA 来验证（这个 CA 可以完全是自己生成的），客户端同时会发送一个用服务器证书加密过的随机数 <strong>PreMasterSecret</strong>，然后客户端会发送一个前一个握手阶段的消息的签名来告诉服务器，客户端是的确是拥有当前证书的（有私钥），然后客户端以及服务器会根据 PreMasterSecret 以及随机数，来生成一个公共的 secret，叫做 <strong>Master secret</strong>；</li><li>  第四阶段：加密通信，两边开始都用 <strong>Master secret</strong> 来进行对称的加解密；</li></ul><p>如果把第三阶段省略掉，那就变成单向认证了，所以担心加密过程开销的同学们可以稍稍省点心了，因为整个过程中，就是 SSL 握手阶段的开销会略微加大，而实际通信过程中的开销还是与单向认证一样。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>所谓中间人攻击，就是在双方握手阶段，由于没有用 CA 对证书进行验证造成的问题：比如你如果不在意浏览器的警告，或者被骗安装了攻击者提供的 CA 证书。攻击者可以在你与服务器建立 SSL 通信的时候，先用假的证书与你建立 SSL 通信，然后再与服务器建立 SSL 通信，这个过程中，攻击者就能拿到这个过程中所有的明文消息。</p><p>用一个非常简单的例子来说明，就是 HTTPS 抓包，比如现在你需要抓手机上的 HTTPS 请求，那么你就需要在手机上安装抓包工具提供的 CA 证书，然后配置好代理后，就可以抓到 HTTPS 的明文请求了。</p><h3 id="我们的问题"><a href="#我们的问题" class="headerlink" title="我们的问题"></a>我们的问题</h3><p>到目前，我们知道了 HTTPS 双向认证是怎么一回事，那么它能解决我们的什么问题呢？防止有人冒充我们的客户端来请求服务器的私有资源，那么我们可以直接去验证客户端的身份，就能在很大程度上解决问题。</p><p>下面自问自答，来帮大家理清楚思路：</p><h4 id="为什么不用自己的方式来加密呢？"><a href="#为什么不用自己的方式来加密呢？" class="headerlink" title="为什么不用自己的方式来加密呢？"></a>为什么不用自己的方式来加密呢？</h4><p>相信这样的场景很常见，为了保护接口，直接跟客户端约定一个密钥，然后大家根据这个密钥来进行加密通信，这种方案在我看来很容易破解，而且一旦破解拿到密钥，你很难短时间里面通过更新客户端来更换密钥。</p><p>这种方式，做的好的能够使用公开经得起验证的加密算法，而做的差的会用私有加密算法（多个公开算法叠加套用不算私有）。这在一定程度上能够阻挡破解者，只是私有加密算法出问题的概率在遇到<strong>高价值资源</strong>的时候，就会变得非常大，简而言之，就如闭源与开源一般。</p><p>另外，还有个很尴尬的地方在于，在开发人员进行接口调试的时候，一大段密文信息将会让调试非常困难。于是，所谓的的防止破解，更多的时候都在恶心开发者自己了。</p><p>用 HTTPS 证书就不会有这个问题了，在自己电脑安装完成证书后，就能在浏览器中明文调试了。</p><h4 id="会给服务器造成很大压力吗？"><a href="#会给服务器造成很大压力吗？" class="headerlink" title="会给服务器造成很大压力吗？"></a>会给服务器造成很大压力吗？</h4><p>理论上，跟 HTTPS 单向的认证区别就在于多了一步验证客户端证书的过程，因此会多出 SSL 握手时的开销，具体我还没有压力测试过，但是我相信玩过 kubernetes 的应该会对此有个概念。</p><p>如果你预计会有比较大的流量，不放心，那就建议先找几台机器进行测试再决定也不迟。</p><h4 id="客户端证书不是也有泄露的风险吗？"><a href="#客户端证书不是也有泄露的风险吗？" class="headerlink" title="客户端证书不是也有泄露的风险吗？"></a>客户端证书不是也有泄露的风险吗？</h4><p>确实如此，如果客户端会流落在他人手里，那么在不加一层保护的前提下，确实有可能会泄露，只是你有两种方案可以一起使用来保护证书：</p><ol><li> 混淆客户端证书，让破解者无法通过简单的 <code>strings</code> 命令, 或者解压你的安装包就能获取到明文证书。另外，你也可以直接用 pkcs12 格式的证书，记得更换一个更强的密码；</li><li> 即使证书泄露，你还可以在服务器配置一个撤销证书列表，这样，被泄露的证书就没有权限来访问了；</li></ol><h4 id="为何我对于客户端证书如此推崇？"><a href="#为何我对于客户端证书如此推崇？" class="headerlink" title="为何我对于客户端证书如此推崇？"></a>为何我对于客户端证书如此推崇？</h4><p>我的理由主要有两点：</p><ol><li> 有着广泛的支持，操作系统本身以及各种反向代理 Nginx、Apache，网络工具 curl、wget 以及各种语言等；</li><li> 加密通信是应该由通信协议本身来解决的问题，它应该与具体传输的内容解耦，所以它还能支持其它协议，比如 MQTT、AMQP 等等；</li></ol><p>大多数没有选择客户端证书的，我认为是因为对它不够了解，或者说它的强大显得过于简单，导致很多人都没有什么安全感，尤其是领导没有什么安全感，但是请大家不妨想想现在有谁能够简单破解 HTTPS 请求内容呢？基于 RSA 加密的通信，是我们现代互联网的安全基础，没有谁能够轻易破解。</p><h3 id="如何实现2、3"><a href="#如何实现2、3" class="headerlink" title="如何实现2、3"></a>如何实现<sup><a href="https://coreos.com/os/docs/latest/generate-self-signed-certificates.html">2</a>、<a href="https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/04-certificate-authority.md">3</a></sup></h3><p>目前大部分方案都是拿 OpenSSL + Nginx 来举例的（随便搜索都是一大堆），那我就把 OpenSSL 换成更简单好用的 <a href="https://github.com/cloudflare/cfssl">CFSSL</a> 。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>多种方式可选，比如最简单的就是直接去下载已经编译好的工具：<a href="https://github.com/cloudflare/cfssl/releases">cfssl/releases</a> 。</p><p>我目前使用的是 v1.5.0 版本的，大版本前提下，命令应该不会相差太多。</p><h4 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h4><p>生成 CA 默认配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl print-defaults config &gt; ca-config.json</span><br></pre></td></tr></table></figure><p>这里面的内容需要略加修改，下面给出一个我修改的例子，因为今天只需要客户端证书，因此 profiles 里面只留下了 client，<code>signing.default.expiry</code> 表示签发证书的默认过期时间，时间比较短，而另一个 <code>signing.profiles.client.expiry</code> 则比较长，8760h 就表示一年了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;signing&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;default&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;expiry&quot;</span>: <span class="string">&quot;168h&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;client&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;expiry&quot;</span>: <span class="string">&quot;8760h&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;usages&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;signing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是生成 CA 证书申请：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl print-defaults csr &gt; ca-csr.json</span><br></pre></td></tr></table></figure><p>也需要根据自己的情况修改，这里需要注意下 key，v1.5.0 下面默认是 ecdsa-256 ，而我改成了 rsa-2048，只是为了说明方便，以及兼容性。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;Awesome Inc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Guangdong&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Shenzhen&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;Awesome Inc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;Tech Dept&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以生成 CA 证书了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br></pre></td></tr></table></figure><p>在当前目录下，会生成三个文件：</p><ul><li>  ca-key.pem CA 密钥</li><li>  ca.csr CA 证书请求</li><li>  ca.pem CA 证书</li></ul><h4 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h4><p>接下来就开始生产客户端证书，与上面是类似的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl print-defaults csr &gt; client.json</span><br></pre></td></tr></table></figure><p>照例给出 client.json 的修改样例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;xizhibei&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span>: [<span class="string">&quot;&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Guangdong&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Shenzhen&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;Awesome Inc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;Tech Dept&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client client.json | cfssljson -bare client</span><br></pre></td></tr></table></figure><p>命令行中会出现如下的日志：</p><pre><code>2021/02/03 15:21:09 [INFO] generate received request2021/02/03 15:21:09 [INFO] received CSR2021/02/03 15:21:09 [INFO] generating key: rsa-20482021/02/03 15:21:10 [INFO] encoded CSR2021/02/03 15:21:10 [INFO] signed certificate with serial number 657128885698804019594922156238712961504332210277</code></pre><p>然后生成了三个文件：</p><ul><li>  xizhibei-key.pem</li><li>  xizhibei.csr</li><li>  xizhibei.pem</li></ul><h4 id="撤销证书"><a href="#撤销证书" class="headerlink" title="撤销证书"></a>撤销证书</h4><p>当证书发布出去后，在有效期之前，它是一直有效的，但是如果我们想让它提前失效（比如泄露的情况下），那么就需要用到撤销证书。</p><p>比如，我们要撤销上面刚刚生成的证书，需要先将序列号写入撤销证书序列号列表，然后来生成撤销证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 657128885698804019594922156238712961504332210277 &gt;&gt; crl-serials.txt</span><br><span class="line">cfssl gencrl crl-serials.txt ca.pem ca-key.pem| base64 -D | openssl crl -inform DER -out ca-crl.pem</span><br></pre></td></tr></table></figure><p>然后替换已有的撤销证书即可。</p><p>好了，到目前为止，证书部分基本上就搞定了，相对 OpenSSL 来说是不是很简单？</p><h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><p>将上面生成的 <code>ca.pem</code> 以及 <code>ca-crl.pem</code> 放在 <code>/etc/nginx/certs/client_ca</code> 中，然后在 server 中如下配置（这里假设你已经开启了 HTTPS，并且配置好了服务端的证书）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssl_client_certificate &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;client_ca&#x2F;ca.pem;</span><br><span class="line">ssl_crl &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;client_ca&#x2F;ca-crl.pem;</span><br><span class="line">ssl_verify_client on;</span><br></pre></td></tr></table></figure><p>更新 Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>这里留给你一个思考题，为什么这里只需要配置一个 CA 证书就可以了？</p><h4 id="客户端证书的安装"><a href="#客户端证书的安装" class="headerlink" title="客户端证书的安装"></a>客户端证书的安装</h4><p>如果你在配置好 nginx 后，直接用浏览器请求网站，那么你就会看到一个 HTTP 400 错误，告诉你需要提供证书。</p><p><img src="https://blog.xizhibei.me/media/16120752577354/16123454428511.jpg" alt="nginx 400 bad request"></p><p>本地安装证书很简单，直接鼠标双击证书就能够安装，如果是 Mac，记得在 Keychain 中配置始终信任。</p><p>另外，为了方便发送证书给他人使用，建议打包成 <code>pkcs12</code> 格式的证书，还能设置密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts \</span><br><span class="line">    -CApath . -inkey xizhibei-key.pem -<span class="keyword">in</span> xizhibei.pem \</span><br><span class="line">    -certfile ca.pem -passout pass:strong-password -out xizhibei.p12</span><br></pre></td></tr></table></figure><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake">Transport Layer Security</a></li><li> <a href="https://coreos.com/os/docs/latest/generate-self-signed-certificates.html">Generate self-signed certificates</a></li><li> <a href="https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/04-certificate-authority.md">kubernetes-the-hard-way</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/159">https://github.com/xizhibei/blog/issues/159</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/02/03/https-two-way-authentication-with-certificates/" target="_blank">https://blog.xizhibei.me/2021/02/03/https-two-way-authentication-with-certificates/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: https-two-way-authentication-with-certificates --&gt;

&lt;p&gt;在很久之前，我在 &lt;a href=&quot;https://blog.xizhibei.me/2018/07/29/https-and-ssl-tl</summary>
      
    
    
    
    
    <category term="安全" scheme="https://blog.xizhibei.me/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="HTTPS" scheme="https://blog.xizhibei.me/tags/HTTPS/"/>
    
    <category term="反爬虫" scheme="https://blog.xizhibei.me/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    <category term="工具" scheme="https://blog.xizhibei.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>穷人的程序性能分析器</title>
    <link href="https://blog.xizhibei.me/2021/01/10/poor-mans-profiler/"/>
    <id>https://blog.xizhibei.me/2021/01/10/poor-mans-profiler/</id>
    <published>2021-01-10T09:38:26.000Z</published>
    <updated>2021-05-01T15:35:48.469Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: poor-mans-profiler --><p>标题是直接翻译自 Poor man’s profiler，也可以叫做<strong>最简陋的程序性能分析方法</strong>。</p><p>这种程序性能分析分析方式还是非常有意思的，第一次见到它时在 <a href="https://stackoverflow.com/questions/375913/how-can-i-profile-c-code-running-on-linux">Stack Overflow 的一个问答</a>里面，本以为最高票答案的方式会介绍一个非常牛逼的工具，哪知道他介绍的却是一种朴实无华的 Profiler 方式。</p><p>我本来也直接跳过了这个回答，觉得太不靠谱了，但是在一一尝试了 gperf、vargrind、perf 等未果之后（主要是因为程序在开发板上，这些工具都没法很好地支持），于是我尝试了下这个方案，不出所料的，居然真解决了我的问题，很简单的几个步骤就找出程序的性能瓶颈所在。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这里就简单挑重点，翻译下作者 Mike Dunlavey 的回答：</p><blockquote><p>在调试的时候，停住几次程序，每次停止后，检查下调用堆栈。如果有代码占用了整个程序一定比例的 CPU 时间，那么你就有较大的可能性会在这几次查看堆栈的时候发现它们。</p><p>当然，你也许有多个不同大小的性能问题，如果你解决了其中一个，那么剩下的占用的 CPU 时间就会变大，也就会变得更容易发现。这种放大效应，当遇到多个问题交织在一起的时候，可以成为真正的加速因子。</p></blockquote><p>显然，这种方式过于简陋了，导致被许多人质疑，作者就花费了不少时间来跟人辩论。</p><p>首先是说，其他的那些高级工具，给出的调用关系图有两个很大的缺点，一个是无法给出指令级别，另外还会在遇到递归时给出让人费解的统计。</p><p>另外的一些针对大家提出的问题，统一用贝叶斯统计来进行了理论上的解释，总的来说还是非常令人信服的。</p><p>最后作者把用 perf 等工具测量所有的程序调用过程叫做测量，而用 Poor man’s profiler 叫做程序调用栈采样。这两种分析方式的区别在于：前者是<strong>水平</strong>的，它会告诉你那些步骤所花费的时间，后者是<strong>垂直</strong>的，它会告诉你程序在此刻在做什么，如果你第二次发现它还在做这件事，那就意味着这就是瓶颈了。</p><p>这其实就跟领导为了了解属下是不是在认真工作（找出公司运作瓶颈），领导不可能在每个人背后装个摄像头来监控（perf 工具测量），进行视察工作（采样）一样，第一次抓到你在摸鱼，领导可能不会说什么，人之常情，可以原谅，但是第二次再抓到你摸鱼，那他就会认为你这个人肯定是在一直偷懒了，你就是性能瓶颈了（嗯，这么说来领导们才是精通程序调试的大牛 :P）。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>上面只是说了原理，这里就说说，如何在实践中使用，我们就用最简单的 gdb 来做：</p><ol><li> 首先是启动 gdb： <code>gdb --attach $(pidof your-app)</code></li><li> 然后关闭 gdb 打印数据的分页配置：<code>set pagination 0</code>，这样就可以让 gdb 输出所有的分页了，当然你也可以不管，手动查看；</li><li> 等 gdb 加载完程序以及依赖的动态库，就可以继续运行了：<code>continue</code>；</li><li> 等个几秒，手动 <code>CTRL-C</code> 暂停程序；</li><li> 输入 <code>bt</code> 即 <code>backtrace</code>，就能看到当前程序停住的调用栈了，当然，如果是多线程的程序，你可能需要看所有线程的调用栈：<code>thread apply all bt</code>；</li><li> 重复 3、4、5 步骤几次，统计下程序经常停住的地方了，如果同一个指令在多次采用中出现，你就几乎能发现你程序的性能问题所在了；</li></ol><p>熟悉这个流程后，你也可以写个脚本来进行自动化。但是其中你需要了解两个关键的地方：</p><p>一个关键地方是在上面的步骤中，我们采取的是手动 <code>CTRL-C</code> 暂停程序，但是在脚本里面，你很难这么去干，于是你可以用 <code>TRAP</code> 信号来达到同样的效果，具体就是 <code>kill -TRAP $(pidof your-app)</code>。</p><p>另一个关键地方就是，<code>kill</code> 需要自动执行，为达到这个目的，我们还需要 bash 脚本的另外一个技巧，即多进程，在任何一条命令最后加上 <code>&amp;</code> 就可以将这个命令放到后台去执行，于是你可以配合 <code>sleep</code> 命令来达到这个目的，即最终拼凑出类似于这样的命令：<code>sh -c &quot;sleep 5 &amp;&amp; kill -TRAP $(pidof your-app)&quot; &amp;</code> ，这条命令不会阻塞下面其他的命令，并且在 5 秒之后，执行 kill 命令。</p><p>最终，我们可以写出一个类似于下面的脚本（抄袭的原脚本在 <a href="http://poormansprofiler.org/">Poor man’s profiler</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">nsamples=5</span><br><span class="line">sleeptime=25</span><br><span class="line">gdb_cmd_file=<span class="string">&quot;/tmp/gdb-cmd.sh&quot;</span></span><br><span class="line">gdb_log_file=<span class="string">&quot;/tmp/gdb.log&quot;</span></span><br><span class="line"></span><br><span class="line">pid=$(pidof your-app)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;set pagination 0&quot;</span> &gt;&gt; <span class="variable">$gdb_cmd_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 gdb 命令写入文件，然后用 gdb 的 -x 参数执行</span></span><br><span class="line"><span class="comment"># 40 秒是为了等待 gdb 加载完成，然后每次累加 $sleeptime</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 <span class="variable">$nsamples</span>); <span class="keyword">do</span></span><br><span class="line">  sleep_for=$(expr <span class="variable">$i</span> \* <span class="variable">$sleeptime</span> + 40)</span><br><span class="line">  sh -c <span class="string">&quot;sleep <span class="variable">$sleep_for</span> &amp;&amp; kill -TRAP <span class="variable">$pid</span>&quot;</span> &amp;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;continue&quot;</span> &gt;&gt; <span class="variable">$gdb_cmd_file</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;thread apply all bt&quot;</span> &gt;&gt; <span class="variable">$gdb_cmd_file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志写入文件与终端</span></span><br><span class="line">gdb --attach <span class="variable">$pid</span> -x <span class="variable">$gdb_cmd_file</span> --batch | tee <span class="variable">$gdb_log_file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计结果</span></span><br><span class="line">cat <span class="variable">$gdb_log_file</span> | \</span><br><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  BEGIN &#123; s = &quot;&quot;; &#125;</span></span><br><span class="line"><span class="string">  /^Thread/ &#123; print s; s = &quot;&quot;; &#125;</span></span><br><span class="line"><span class="string">  /^\#/ &#123; if (s != &quot;&quot; ) &#123; s = s &quot;,&quot; $4&#125; else &#123; s = $4 &#125; &#125;</span></span><br><span class="line"><span class="string">  END &#123; print s &#125;&#x27;</span> | \</span><br><span class="line">sort | uniq -c | sort -r -n -k 1,1</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>果然是一种低成本且效率高的方法，几乎可以说是朴实无华了。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="http://poormansprofiler.org/">http://poormansprofiler.org/</a></li><li> <a href="https://stackoverflow.com/questions/375913/how-can-i-profile-c-code-running-on-linux">https://stackoverflow.com/questions/375913/how-can-i-profile-c-code-running-on-linux</a></li><li> <a href="https://stackoverflow.com/questions/1777556/alternatives-to-gprof">https://stackoverflow.com/questions/1777556/alternatives-to-gprof</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/158">https://github.com/xizhibei/blog/issues/158</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/01/10/poor-mans-profiler/" target="_blank">https://blog.xizhibei.me/2021/01/10/poor-mans-profiler/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: poor-mans-profiler --&gt;

&lt;p&gt;标题是直接翻译自 Poor man’s profiler，也可以叫做&lt;strong&gt;最简陋的程序性能分析方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这种程序性能分析分析方式还是非常有意思的，第一次见到</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://blog.xizhibei.me/tags/C-C/"/>
    
    <category term="工具" scheme="https://blog.xizhibei.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>2020 总结</title>
    <link href="https://blog.xizhibei.me/2021/01/01/summary-of-2020/"/>
    <id>https://blog.xizhibei.me/2021/01/01/summary-of-2020/</id>
    <published>2021-01-01T13:40:44.000Z</published>
    <updated>2021-05-01T15:35:48.469Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: summary-of-2020 --><p>今年总的来说，是比较<strong>颓</strong>的一年，首先是疫情带来的影响，无论是成长还是机遇；其次是自己今年放弃了几个好习惯，比如坚持每两周一篇的博客，每周两次的锻炼以及坚持阅读。</p><p>对于新冠疫情，到目前还是没有结束，虽然已经有疫苗上市了，看情况还是得持续一段时间。不过也有好事，各种公共场合大家都很自觉地戴着口罩，于是除了新冠病毒，今年各种呼吸道传染病减少了很多。虽说没有染上新冠，但是自己身体上的退步还是很明显的：今年又确诊了两种慢性病，腰肌劳损以及慢性胃炎。</p><h3 id="厨艺"><a href="#厨艺" class="headerlink" title="厨艺"></a>厨艺</h3><p>去年给今年定的计划中，有提高厨艺这个选项，然而拜疫情所赐，这个计划竟然是第一个完成的，并且提前完成了大半年。</p><p>目前最喜欢做，也是自己最喜欢吃的菜：</p><ul><li>  日式肥牛饭</li><li>  鸡肉咖喱饭</li><li>  腊肠焖饭</li><li>  意大利番茄肉酱 + 意大利面</li><li>  螺蛳粉（这个也不算菜，只是今年吃了好多 :P）</li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>今年明显感觉到了写博客的吃力起来了，写了一个 CMake 系列之后，就很难有比较好的内容来进行写作了，我觉得，这也是自己积累不够多的表现。</p><p>尽管也想去写其它的系列，比如密码学、数字图像处理，奈何自己投入的精力不够，也可以说是积累不够，没法一下子就把这几块骨头给啃下来。</p><p>不管怎样，这个系列是自己写的最长的，也算小有成就感：</p><ol><li> <a href="https://blog.xizhibei.me/2020/03/09/cmake-1-introduction/">（一）入门</a></li><li> <a href="https://blog.xizhibei.me/2020/03/15/cmake-2-third-party-dependances-management/">（二）第三方依赖管理</a></li><li> <a href="https://blog.xizhibei.me/2020/03/23/cmake-3-external-project-practise/">（三）ExternalProject 实践</a></li><li> <a href="https://blog.xizhibei.me/2020/04/05/cmake-4-test-with-google-test/">（四）用 GoogleTest 测试</a></li><li> <a href="https://blog.xizhibei.me/2020/04/20/cmake-5-install-package-and-export/">（五）安装、打包与导出</a></li><li> <a href="https://blog.xizhibei.me/2020/05/19/cmake-6-docs-with-doxygen-sphinx-breathe/">（六）用 Doxygen、Sphinx 与 Breathe 创建文档</a></li><li> <a href="https://blog.xizhibei.me/2020/06/02/cmake-7-common-var-func-and-modules/">（七）常用变量、函数以及模块</a></li><li> <a href="https://blog.xizhibei.me/2020/06/15/cmake-8-cross-compiling/">（八）交叉编译</a></li><li> <a href="https://blog.xizhibei.me/2020/06/30/cmake-9-implement-download-extract-file/">（九）实战之如何下载依赖</a></li><li><a href="https://blog.xizhibei.me/2020/07/29/cmake-10-refine-compile-speed-and-program-performance/">（十）编译速度以及程序性能优化相关</a></li></ol><p>这方面的总结可以看 <a href="https://blog.xizhibei.me/2020/08/30/finish-of-cmake-and-small-talks/">CMake 系列完结以及一些碎碎念</a>  ，就不在这里赘述了。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>现在主业又开始了新的技能树分支，逐渐拓展自己在 C++ 以及嵌入式系统方面的知识，今年最大的体会就是，原来硬件带来的性能提升是那么明显（当然了，可能是因为自己不怎么玩游戏，没体会过更换显卡带来的性能体验）。</p><p>就拿加密算法来说，在普通 PC 上实现的 AES 256 ECB 算法，可能会达到 80M/s，而到了嵌入式设备上，纯用 CPU 就会变成 5 M/s，而这时候换成硬件加密，则能够达到 100M/s 。</p><p>另外就是 C/C++ 了，虽然是之前学过，但是如今再次上起手来还是会觉得不适应，毕竟接触过更现代的 Go，Rust，Node.js 后，就会有天然的不适应。缺少了那些随手可得的工具、依赖以及文档，实现功能时需要考虑的东西更多了，尤其当涉及到操作系统、内存管理的时候，非常让人头大。</p><p>所以，目前的开发过程中，会尽量不去考虑引入新的依赖，如果要引入依赖，首先是查找一番，对比几个项目的优劣，然后，必须要读源码，尤其是那些文档不佳的项目，还必须深入阅读。如此我才明白有经验的 C++ 工程师是多么宝贵的存在了，凭借熟悉的那些依赖，他就可以在更短的时间里面把事情做成，并且做好。</p><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>读书有点遗憾，今年把过多时间用来刷 B 站了，虽然不会跟抖音一样令人沉迷，但是一旦看了之后还是会在不知不觉中消耗了时间，好吧，其实也可以算是沉迷（比如非常喜欢观察者的一些节目，比如王骁的骁话一下、马前卒的睡前消息、董佳宁的懂点儿啥以及沈逸老师的逸语道破，当然还有罗翔老师的刑法学等等），只是在这个过程中，也会学到一些知识，甚至我觉得对比与书来说，吸收知识的效率更高。</p><p>话说回来，这些知识，也是所谓的碎片化知识，无法带给我系统的知识，所以理性点说，就是娱乐。</p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p>首先报告下今年的理财成绩：25%，只是粗略计算，实际应该会比这个数字高 1%-2%。</p><p>之所以达到这个程度，我认为一个是自己看准时机下重注了：疫情初期自己也几乎是拿出每月的工资去抄底基金了，然而最重要的是国运发展好，最终控制住了疫情，让我敢于抄底。</p><p>在证券市场中，我们把贝塔收益指市场平收益，而把超出市场平均回报的收益叫做阿尔法收益，所以大家明白了，今年我的主要受益来自于<strong>贝塔收益</strong>。</p><h3 id="记账"><a href="#记账" class="headerlink" title="记账"></a>记账</h3><p>今年记账了一整年，几乎手动记录了自己所有的支出，也几乎养成了每笔消费之后的习惯性记账。</p><p>有人可能会说，现在有那么多自动记账的工具了，为什么还要自己费劲手动记账呢？确实现在几乎每一笔消费，都会被微信、支付宝甚至银行自动记录下来，并且还能够提供一些简单的分析、总结。只是，它们共同的缺点就是很难去兼容彼此，一旦你用不同的银行或者客户端，都有可能将你的消费打散开来。</p><p>还有人会说，写个脚本统一导入记账软件即可，这个我不否认，有些记账软件可以直接对接支付宝微信的导出账单，甚至银行。非常便利，而我不选择的理由就是隐私，作为互联网从业人员，我深感个人隐私泄露的可能性之高，因为数据库被拖，甚至主动卖出数据也是见怪不怪了，因此，我对于国内的这帮互联网大厂，有深深的不信任感。不过，我相信在国家力量的介入下，法制会越来越完善，行业也会越来越注重用户的隐私，真正把用户的隐私当回事，而不是永远以为用户会用隐私换取便利。</p><p>其实，之前尝试过不同的记账方式，到了最后都逐渐放弃了，因为那些记账方式，都没有让自己深度参与到其中，记账的工作被机器自动化了，以至于对于最后的账单统计也最多只会轻叹一声：「天，这个月花怎么花那么多？」。</p><p>说了半天，其实自己手动记账是一个<strong>能让自己对于花出去的每一分钱更有意识的行为</strong>，这样做，多少都会找回那种数字简单减少而产生的无动于衷的感觉。</p><p>今年记了一整年的帐后，从月账单的统计中，真正意识到了自己在过怎么样的一种生活。然而，自己还是缺乏制作并实施预算的习惯，所以，也没法去掌控自己过什么样的生活。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>新年快乐，博客我还会写下去的，毕竟还有那么多的朋友关注我，只是目前频率不能保持恒定了。</p><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/157">https://github.com/xizhibei/blog/issues/157</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2021/01/01/summary-of-2020/" target="_blank">https://blog.xizhibei.me/2021/01/01/summary-of-2020/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: summary-of-2020 --&gt;

&lt;p&gt;今年总的来说，是比较&lt;strong&gt;颓&lt;/strong&gt;的一年，首先是疫情带来的影响，无论是成长还是机遇；其次是自己今年放弃了几个好习惯，比如坚持每两周一篇的博客，每周两次的锻炼以及坚持阅读。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="年度总结" scheme="https://blog.xizhibei.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>RTSP 服务器的简单实现</title>
    <link href="https://blog.xizhibei.me/2020/12/20/a-simple-implementation-of-rtsp-server/"/>
    <id>https://blog.xizhibei.me/2020/12/20/a-simple-implementation-of-rtsp-server/</id>
    <published>2020-12-20T13:50:42.000Z</published>
    <updated>2021-05-01T15:35:48.461Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: a-simple-implementation-of-rtsp-server --><p>在上次的 <a href="https://blog.xizhibei.me/2020/10/26/rtsp-explain/">RTSP 协议详解</a> 中，把 RTSP 协议本身简单介绍了，这次就来说说如何实现一个简单的 RTSP 服务器。</p><h3 id="Live555"><a href="#Live555" class="headerlink" title="Live555"></a>Live555</h3><p>Live555 是我们经常用的 C++ 媒体库，它支持非常多的媒体服务协议，实现了对多种音视频编码格式的音视频数据的数据流化、接收和处理等支持。</p><p>它也是现在为数不多的可用库之一，它的代码比较繁琐，但是胜在简单，多数人拿到之后就能简单上手了，因此也非常适合拿来练手，以及改写。</p><h3 id="一个简单的-RTSP-H264-实现"><a href="#一个简单的-RTSP-H264-实现" class="headerlink" title="一个简单的 RTSP/H264 实现"></a>一个简单的 RTSP/H264 实现</h3><p>我们拿 <code>testProgs/testOnDemandRTSPServer.cpp</code> 作为例子。</p><p>首先创建 RTSP 服务本身：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TaskScheduler* scheduler = BasicTaskScheduler::<span class="built_in">createNew</span>();</span><br><span class="line">env = BasicUsageEnvironment::<span class="built_in">createNew</span>(*scheduler);</span><br><span class="line"></span><br><span class="line">UserAuthenticationDatabase* authDB = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"># 这里如果不需要认证的话，可以去掉</span><br><span class="line">authDB = <span class="keyword">new</span> UserAuthenticationDatabase;</span><br><span class="line">authDB-&gt;<span class="built_in">addUserRecord</span>(<span class="string">&quot;username1&quot;</span>, <span class="string">&quot;password1&quot;</span>);</span><br><span class="line"></span><br><span class="line"># 监听 <span class="number">554</span> 端口，标准的 RTSP 端口</span><br><span class="line">RTSPServer* rtspServer = RTSPServer::<span class="built_in">createNew</span>(*env, <span class="number">554</span>, authDB);</span><br></pre></td></tr></table></figure><p>然后添加 H264 文件作为视频源，如果不太理解，可以联想上面创建了 HTTP 服务器，而下面则在服务里面添加了 HTTP 路由资源的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* streamName = <span class="string">&quot;h264ESVideoTest&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* inputFileName = <span class="string">&quot;test.264&quot;</span>;</span><br><span class="line">ServerMediaSession* sms</span><br><span class="line">  = ServerMediaSession::<span class="built_in">createNew</span>(*env, streamName, streamName,</span><br><span class="line">      descriptionString);</span><br><span class="line">sms-&gt;<span class="built_in">addSubsession</span>(H264VideoFileServerMediaSubsession</span><br><span class="line">       ::<span class="built_in">createNew</span>(*env, inputFileName, reuseFirstSource));</span><br><span class="line">rtspServer-&gt;<span class="built_in">addServerMediaSession</span>(sms);</span><br></pre></td></tr></table></figure><h3 id="基于摄像头的视频流"><a href="#基于摄像头的视频流" class="headerlink" title="基于摄像头的视频流"></a>基于摄像头的视频流</h3><p>在这里，你需要注意到，Live555 的 RSTP 服务器是基于文件去做的，如果你的视频源不是一个静态的文件，那你就需要自己去实现 <code>ServerMediaSubsession</code> 了。</p><p>目前，我搜索到的方案主要有两种，一种方案是利用 Linux 的命名管道 <code>fifo</code> 来进行数据的传输，这样就可以在不实现 <code>ServerMediaSubsession</code> 的情况下直接使用。</p><p>具体就是用 Linux 的 <code>mkfifo</code> 命令，或者系统 API 调用创建一个管道，然后就可以使用文件的的 API 来进行读写（不得不赞叹 Linux 的精巧之处，一切皆文件）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo [OPTION]... NAME...</span><br></pre></td></tr></table></figure><p>然而，我没有进行测试，不过看各种论坛上的提问以及经验总结来看，这种方案虽然简洁，但是性能堪忧，并且会造成很大的延迟。</p><p>那么，另一种方案就呼之欲出了，其实新版本中，Live555 已经给出了解决方案的例子，就在 <code>liveMedia/DeviceSource.cpp</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">DeviceSource*</span><br><span class="line">DeviceSource::<span class="built_in">createNew</span>(UsageEnvironment&amp; env,</span><br><span class="line">DeviceParameters params) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DeviceSource</span>(env, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventTriggerId DeviceSource::eventTriggerId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> DeviceSource::referenceCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">DeviceSource::<span class="built_in">DeviceSource</span>(UsageEnvironment&amp; env,</span><br><span class="line">   DeviceParameters params)</span><br><span class="line">  : <span class="built_in">FramedSource</span>(env), <span class="built_in">fParams</span>(params) &#123;</span><br><span class="line">  <span class="keyword">if</span> (referenceCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 任何的全局初始化，比如设备的初始化</span></span><br><span class="line">    <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line">  &#125;</span><br><span class="line">  ++referenceCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例级别的初始化</span></span><br><span class="line">  <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来就是设置如何从设备上读取视频帧，有两种方式，一种是可以直接读取的，具体例子可以搜索 turnOnBackgroundReadHandling</span></span><br><span class="line">  <span class="built_in">envir</span>().<span class="built_in">taskScheduler</span>().<span class="built_in">turnOnBackgroundReadHandling</span>(...);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 另一种则是需要异步读取的，这样的话，就需要用到事件触发的方式读取</span></span><br><span class="line">  <span class="keyword">if</span> (eventTriggerId == <span class="number">0</span>) &#123;</span><br><span class="line">    eventTriggerId = <span class="built_in">envir</span>().<span class="built_in">taskScheduler</span>().<span class="built_in">createEventTrigger</span>(deliverFrame0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeviceSource::~<span class="built_in">DeviceSource</span>() &#123;</span><br><span class="line">  <span class="comment">// 释放实例资源</span></span><br><span class="line">  <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line"></span><br><span class="line">  --referenceCount;</span><br><span class="line">  <span class="keyword">if</span> (referenceCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 释放全局资源</span></span><br><span class="line">    <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reclaim our &#x27;event trigger&#x27;</span></span><br><span class="line">    <span class="built_in">envir</span>().<span class="built_in">taskScheduler</span>().<span class="built_in">deleteEventTrigger</span>(eventTriggerId);</span><br><span class="line">    eventTriggerId = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeviceSource::doGetNextFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当下游，如 RTSP 客户端请求数据时，此方法会被调用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当设备不可读了之后，比如关闭，在这里需要处理下</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> <span class="comment">/*%%% TO BE WRITTEN %%%*/</span>) &#123;</span><br><span class="line">    <span class="built_in">handleClosure</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果视频帧数据可用了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> <span class="comment">/*%%% TO BE WRITTEN %%%*/</span>) &#123;</span><br><span class="line">    <span class="built_in">deliverFrame</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无视频帧数据时，不用做任何事了，但是当数据可用时，需要调用触发事件</span></span><br><span class="line">  <span class="comment">// Instead, our event trigger must be called (e.g., from a separate thread) when new data becomes available.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeviceSource::deliverFrame0</span><span class="params">(<span class="keyword">void</span>* clientData)</span> </span>&#123;</span><br><span class="line">  ((DeviceSource*)clientData)-&gt;<span class="built_in">deliverFrame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeviceSource::deliverFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 此方法会在视频数据帧可用时调用</span></span><br><span class="line">  <span class="comment">// 下面的参数将会用于将数据拷贝至下游（客户端等）</span></span><br><span class="line">  <span class="comment">//     fTo: 拷贝至地址，只能拷贝数据，不可修改</span></span><br><span class="line">  <span class="comment">//     fMaxSize: 最大可拷贝数据，不可修改，如果实际数据大于此数值，则需要截取，并且相应地修改 &quot;fNumTruncatedBytes&quot;</span></span><br><span class="line">  <span class="comment">//     fFrameSize: 实际数据大小 (&lt;= fMaxSize).</span></span><br><span class="line">  <span class="comment">//     fNumTruncatedBytes: 在上面提到了</span></span><br><span class="line">  <span class="comment">//     fPresentationTime: 视频帧的展示时间，可调用 &quot;gettimeofday()&quot; 设置为系统时间，如果能获取解码器的时间的话更好</span></span><br><span class="line">  <span class="comment">//     fDurationInMicroseconds: 视频帧的持续时间，如果是实时视频源，不需要设置，因为这会导致数据永远不会早到达客户端</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isCurrentlyAwaitingData</span>()) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">u_int8_t</span>* newFrameDataStart = (<span class="keyword">u_int8_t</span>*)<span class="number">0xDEADBEEF</span>; <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line">  <span class="keyword">unsigned</span> newFrameSize = <span class="number">0</span>; <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newFrameSize &gt; fMaxSize) &#123;</span><br><span class="line">    fFrameSize = fMaxSize;</span><br><span class="line">    fNumTruncatedBytes = newFrameSize - fMaxSize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fFrameSize = newFrameSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;fPresentationTime, <span class="literal">NULL</span>); <span class="comment">// 如果没有实时视频源的时间戳，就获取当前系统时间</span></span><br><span class="line">  <span class="comment">// 如果设备不是实时视频源，比如文件，那就在这里设置 &quot;fDurationInMicroseconds&quot;</span></span><br><span class="line">  <span class="built_in">memmove</span>(fTo, newFrameDataStart, fFrameSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传送完数据，通知读取方数据可用</span></span><br><span class="line">  FramedSource::<span class="built_in">afterGetting</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码就是用来通知 DeviceSource 视频源可用的代码（异步方式），可以在不同线程中调用，但是不能在多个线程中用同样的 &#x27;event trigger id&#x27; 调用（这样的话，会导致只会触发一次）。另外，如果有多个视频源，则需要修改 eventTriggerId 为非静态成员。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalNewFrameData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  TaskScheduler* ourScheduler = <span class="literal">NULL</span>; <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line">  DeviceSource* ourDevice  = <span class="literal">NULL</span>; <span class="comment">//%%% TO BE WRITTEN %%%</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ourScheduler != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ourScheduler-&gt;<span class="built_in">triggerEvent</span>(DeviceSource::eventTriggerId, ourDevice);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前我用这种方式，采用芯片硬编码，能获取在内网 1080P 30fps h.264 1000ms 以下的延迟。当然了，实验代码写得比较粗糙，需要进一步优化了，这里就不放出来了，相信总体思路还是对的。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><a href="https://blog.csdn.net/xwu122930/article/details/78962234">https://blog.csdn.net/xwu122930/article/details/78962234</a><br><a href="https://blog.csdn.net/u012459903/article/details/103099705">https://blog.csdn.net/u012459903/article/details/103099705</a><br><a href="https://blog.csdn.net/weixin_33700350/article/details/86010562">https://blog.csdn.net/weixin_33700350/article/details/86010562</a></p><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/156">https://github.com/xizhibei/blog/issues/156</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/12/20/a-simple-implementation-of-rtsp-server/" target="_blank">https://blog.xizhibei.me/2020/12/20/a-simple-implementation-of-rtsp-server/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: a-simple-implementation-of-rtsp-server --&gt;

&lt;p&gt;在上次的 &lt;a href=&quot;https://blog.xizhibei.me/2020/10/26/rtsp-explain/&quot;&gt;RTSP 协议详解&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://blog.xizhibei.me/tags/C-C/"/>
    
    <category term="视频直播" scheme="https://blog.xizhibei.me/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>磁盘缓存：从一次文件丢失问题说起</title>
    <link href="https://blog.xizhibei.me/2020/11/21/disk-cache-start-with-a-file-missing-problem/"/>
    <id>https://blog.xizhibei.me/2020/11/21/disk-cache-start-with-a-file-missing-problem/</id>
    <published>2020-11-21T06:50:30.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: disk-cache-start-with-a-file-missing-problem --><p>如果你遇到了这样的问题：</p><p>刚往你的 Linux 机器中，写入了个文件，然后直接断电重启，发现文件只剩下了空壳，即产生了一个没有内容，大小为 0 的文件。</p><p>那么，你遇到了磁盘缓存问题，或者更确切的说法是掉电导致的磁盘缓存丢失问题。</p><h3 id="什么是磁盘缓存"><a href="#什么是磁盘缓存" class="headerlink" title="什么是磁盘缓存"></a>什么是磁盘缓存</h3><p>我们在小学二年级学过（是的，我也是天天给毕导视频点赞的），在 Linux 系统（实际上是任何操作系统）中，磁盘读写都是有缓存的，因为这种缓存往往有利于系统的读写加速，毕竟我们大部分场景下遇到的都是多读少写，因此，用暂时用不到的内存来当缓存，空间换时间是非常值得的。</p><p>缓存的作用原理是，当你读了一个文件，Linux 会先检查内存中的缓存有没有对应的内容，没有才会去读磁盘上的内容，然后会先将磁盘上的内存读到内存中，再返回给用户。这样，下一次读的时候，就不用再次从磁盘中读了，这样就会大大减少文件读的时间。</p><p>如果你这时候往这个文件中写了新的内容，Linux 会往缓存中写，而不是直接往磁盘里写，这样，你写文件的时间就会大大减少。只是，写过的缓存会被 Linux 标记为脏了，也就是所谓的内存脏页，Linux 会周期性地收集所有内存脏页，排序整理，然后往磁盘中真正写入，这就是所谓的回写（writeback），也可以叫做刷盘。</p><p>所以，我们的问题的原因就找到了：因为突然掉电时，造成了内存中的脏页来不及刷入磁盘，导致数据丢失。</p><p>这里说个题外话：这个缓存有多大呢？我们来随便看个 Linux 系统的内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">      total      used      free      shared  buff/cache   available</span><br><span class="line">Mem:   7822      2062       197          20        5563        5384</span><br><span class="line">Swap:     0         0         0</span><br></pre></td></tr></table></figure><p>我们可以看到，第五列的名称是 <code>buff/cache</code> ，表示这个系统缓存占用了 5563 MB 的内存，几乎是大部分内存（其实 buffer 与 cache 还是有一定区别的<sup><a href="https://stackoverflow.com/questions/6345020/what-is-the-difference-between-buffer-and-cache-memory-in-linux">1</a></sup>，但是在我们今天讨论的问题中，可以一起对待），但最后一列 available 告诉我们，缓存也是可用的，当你的应用申请内存时，Linux 就会清理缓存，让出内存给你的应用<sup><a href="https://www.linuxatemyram.com/">2</a></sup>。</p><p>至于这些缓存具体用来了干什么，不是今天的主题，这里就略过了，你可以自己做实验<sup><a href="https://www.linuxatemyram.com/play.html">3</a></sup>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To free pagecache:</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">To free reclaimable slab objects (includes dentries and inodes):</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">To free slab objects and pagecache:</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><p>让我们回到开头提到的问题，看看如何解决。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>目前的解决方案有两种，可以单独使用，也可以一起使用。</p><p>第一种是 <code>open</code> 文件的时候，加上 <code>O_SYNC</code> 标志，表示这个文件写的操作需要直接刷盘，也就是说每次调用 <code>write</code> 之后，文件数据和元数据都会写入磁盘，或者调用 <code>fsync/fdatasync/sync</code> 这几个系统调用，效果是一样的。</p><p>不过这种方案的缺点是很明显的，即所有写操作的延迟都会大大增加，不建议在频繁写的地方使用。（ <code>O_DIRECT</code> 不在考虑范围之内，如果你做的是数据库才可以考虑，不然造成的后果是你无法承受的。）</p><p>第二种就是内核参数大法，通过调整内核缓存相关的参数来进行调优，这种方法相对于第一种会温和一些，可以做到尽量不影响系统性能。</p><p>下面就具体说说跟当前这个问题涉及到的几个内核参数。</p><h3 id="缓存相关的内核参数"><a href="#缓存相关的内核参数" class="headerlink" title="缓存相关的内核参数"></a>缓存相关的内核参数</h3><p>大家回想下小学三年级学过的<strong>虚拟内存</strong>相关的内核参数，对的，就在 <code>/proc/sys/vm/</code> 这个目录下，有我们需要的参数。</p><p>当然了，三年级的同学都知道还有 sysctl 这个工具，我们可以直接获取所需要的名称以及对应的值，具体涉及到的有如下几个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a | grep dirty</span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 10</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line">vm.dirty_ratio = 20</span><br><span class="line">vm.dirty_writeback_centisecs = 500</span><br><span class="line">vm.dirtytime_expire_seconds = 43200</span><br></pre></td></tr></table></figure><p>下面我们来一一解释：<sup><a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt">4</a>, <a href="https://superuser.com/questions/1057007/adjust-linux-disk-flush-intervals-to-avoid-blocking-user-processes">5</a>, <a href="https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/">6</a></sup></p><p><code>vm.dirty_background_bytes</code> 以及 <code>vm.dirty_background_ratio</code> 是用来表示脏内存「软」阈值，一旦超过这个阈值，系统后台刷盘进程就会开始运行，将脏数据刷到磁盘上，增大这个值就会增加缓存大小，反之亦然。<code>bytes</code> 与 <code>ratio</code> 的区别就在于前者是绝对值，后者是相对值（内存的百分比），下面同理；</p><p><code>vm.dirty_bytes</code> 以及 <code>vm.dirty_ratio</code> 是用来表示脏内存「硬」阈值，一旦脏数据到达了这个阈值，系统就会阻塞所有 I/O 操作，然后进行刷盘。这个值受磁盘写的速度影响非常大，假如磁盘写很慢，就不能设置太低，否则就会让整个系统卡住比较长的时间了；</p><p><code>vm.dirty_expire_centisecs</code> 是用来表示脏数据的时间阈值，一旦超过这个阈值，就表示对应的脏数据应该刷盘了，减少这个值会减少遇到掉电丢数据问题的概率；</p><p><code>vm.dirty_writeback_centisecs</code> 是用来表示内核检查脏数据的运行间隔，单位是厘秒（秒的百分之一），与 <code>vm.dirty_expire_centisecs</code> 配合起来使用，减少这个值也会进一步减少遇到掉电丢数据问题的概率，<strong>但是多少都会影响系统的性能</strong>；</p><p><code>vm.dirtytime_expire_seconds</code> 这个主要是给 lazytime inode 设置的过期时间，比如 inode 只是更新了 atime，这种更新非常频繁的数据就没必要短时间就更新，而且负责刷盘的是另外一个专门的 dirtytime writeback 进程，因此这个的默认时间比较长：12 小时，这个就不建议调整了，作用不大；</p><p>具体如何调整，就可以按照机器的磁盘读写速度、内存大小以及具体应用场景来平衡系统 IO 性能、数据安全与成本这三者之间的关系（毕竟有钱的情况下，磁盘换 SSD、加大内存以及买个 UPS 就能搞定这些问题了，嗯，有钱真好）。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://stackoverflow.com/questions/6345020/what-is-the-difference-between-buffer-and-cache-memory-in-linux">What is the difference between buffer and cache memory in Linux?</a></li><li> <a href="https://www.linuxatemyram.com/">Help! Linux ate my RAM!</a></li><li> <a href="https://www.linuxatemyram.com/play.html">Experiments and fun with the Linux disk cache</a></li><li> <a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt">linux kernel doc - sysctl vm</a></li><li> <a href="https://superuser.com/questions/1057007/adjust-linux-disk-flush-intervals-to-avoid-blocking-user-processes">networking - Adjust linux disk flush intervals to avoid blocking user processes - Super User</a></li><li> <a href="https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/">Better Linux Disk Caching &amp; Performance with vm.dirty_ratio</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/153">https://github.com/xizhibei/blog/issues/153</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/11/21/disk-cache-start-with-a-file-missing-problem/" target="_blank">https://blog.xizhibei.me/2020/11/21/disk-cache-start-with-a-file-missing-problem/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: disk-cache-start-with-a-file-missing-problem --&gt;

&lt;p&gt;如果你遇到了这样的问题：&lt;/p&gt;
&lt;p&gt;刚往你的 Linux 机器中，写入了个文件，然后直接断电重启，发现文件只剩下了空壳，即产生了一个没有内容</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.xizhibei.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>RTSP 协议详解</title>
    <link href="https://blog.xizhibei.me/2020/10/26/rtsp-explain/"/>
    <id>https://blog.xizhibei.me/2020/10/26/rtsp-explain/</id>
    <published>2020-10-26T10:40:03.000Z</published>
    <updated>2021-05-01T15:35:48.469Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: rtsp-explain --><p>当我们谈到 RTSP 的时候，其实不仅仅是 RTSP 协议本身，我们其实不可避免会谈到以下几个协议：</p><ul><li>  RTP (Real-time Transport Protocol)：真正用来传输音频视频的协议，一般是建立在 UDP 协议的基础上，特别需要注意的是，它使用偶数端口<sup><a href="https://en.wikipedia.org/wiki/Real-time_Transport_Protocol">1</a></sup>；</li><li>  RTCP (Real-time Control Protocol)：RTP 的姊妹协议，通过周期性发送统计信息，提供服务质量（QoS）的反馈，它使用的端口是奇数，而且就是 RTP 端口 +1<sup><a href="https://en.wikipedia.org/wiki/RTP_Control_Protocol">2</a></sup>；</li><li>  SDP (Session Description Protocol)：是应用层的一个协议，也可以说事一个格式，跟 HTML、JSON 之类的算是同一类（在今天的文章里就简单带过了）<sup><a href="https://en.wikipedia.org/wiki/Session_Description_Protocol">3</a></sup>；</li></ul><a id="more"></a><p>这里相信你也能看出一些内容了，比如其实 RTSP 协议本身不负责播放，只负责交互控制，RTP 以及 RTCP 才是真正的视频传输。</p><p>下面我们将其中的详细内容展开来说说，并且会用实际的例子来说明。</p><h3 id="几个协议的详细介绍"><a href="#几个协议的详细介绍" class="headerlink" title="几个协议的详细介绍"></a>几个协议的详细介绍</h3><p>在 Web 开发的时候，我们经常会使用到各种 HTTP 抓包工具，但是，作为一个有追求的工程师，你应该学会使用 WireShark，这是一款强大免费的网络抓包分析工具，它可以让我们看清楚，我们每天在使用的协议究竟是什么样的。</p><p>打开 WireShark （安装的过程就略过了，相信你可以自己搞定的），选择你电脑正在使用的网络端口，比如 Linux 可能是 eth0，Mac 是 en0 ，双击就能进入抓包。</p><p>接着在 WireShark 的筛选栏里，填入 <code>rtsp || rtcp || rtp</code> 这样，我们就能够把一些无关的协议过滤掉。</p><p>在继续之前，你还需要准备的是，一个 RTSP 服务器，我这里准备的是一个网络摄像头，另外就是本地的 RTSP 播放器，比如我就是用 VLC 来播放的。如果你身边暂时没有可用的，也可以临时造一个，可以看看 <a href="https://github.com/aler9/rtsp-simple-server">rtsp-simple-server</a> 里面介绍的。</p><p>当然，还有客户端，我们可以直接用各种播放器（如 VLC）来播放 RTSP 视频源，或者你可以使用命令行， 比如 FFMpeg 的 ffplay：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay rtsp://192.168.1.100/live</span><br></pre></td></tr></table></figure><p>如果你跟我一样使用 VLC：点击打开媒体 -&gt; 网络，然后在 URL 中填入视频源，点击打开就开始播放了，过几秒钟后点击停止播放。</p><h4 id="整体通信过程总览"><a href="#整体通信过程总览" class="headerlink" title="整体通信过程总览"></a>整体通信过程总览</h4><p>下面两张图就是我用 VLC 播放以及停止之间发生的网络通信抓包，其中 192.168.2.31 是网络摄像头，而 192.168.2.115 则是我的电脑，即播放器所在的电脑。</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036923034941.jpg" alt="通信抓包 1"></p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036924099950.jpg" alt="通信抓包 2"></p><p>需要注意到的部分：</p><ol><li> 这次忽略了暂停（PAUSE），以及其它比如 GET_PARAMETER，SET_PARAMETER；</li><li> 在 PLAY 请求的回复之前，我们看到了一个 RTCP 以及 RTP 请求，这说明，在回复之前，播放源已经开始传输播放数据；</li><li> 在后续不断的 RTP 中，有些数据包带有 Mark 字样，这是由于视频数据过大造成了分包；</li></ol><h4 id="RTSP-协议"><a href="#RTSP-协议" class="headerlink" title="RTSP 协议"></a>RTSP 协议</h4><p>接下来，让我们通过实际抓包的内容来作具体说明。</p><h5 id="OPTIONS-请求"><a href="#OPTIONS-请求" class="headerlink" title="OPTIONS 请求"></a>OPTIONS 请求</h5><p>首先，客户端会发送一个与 HTTP 协议很类似的 RTSP 协议到 192.168.1.100 的 554 端口，是一个 OPTIONS 请求，即列出这个播放源可用的请求，注意 CSeq，每个 RTSP 请求都会带上，这样，服务端的回应就会跟客户端一一对应起来（这不就是 HTTP）。</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036926311878.jpg" alt="OPTIONS 请求"></p><p>然后服务器就会回应：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036926489106.jpg" alt="OPTIONS 回复"></p><p>如上，服务器告诉客户端，可以使用 DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE 等几个请求。</p><h5 id="DESCRIBE-请求"><a href="#DESCRIBE-请求" class="headerlink" title="DESCRIBE 请求"></a>DESCRIBE 请求</h5><p>现在，客户端发送 DESCRIBE 请求：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036926623169.jpg" alt="DESCRIBE 请求"></p><p>服务器会用 SDP 格式的内容回应：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036926933772.jpg" alt="DESCRIBE 回复"></p><p>WireShark 的一个非常友好的部分在于，它会把协议的说明描述显示出来，SDP 看不懂？它会很清楚地告诉你，另外，SDP 详细的协议解释清看 <a href="https://en.wikipedia.org/wiki/Session_Description_Protocol">维基上的说明</a> 。</p><p>这里注意下 <code>rtpmap:96 H264/90000</code> 这一行，这里表示这个视频源是用 H264 编码，采样频率是 90000 。</p><p>如上，服务器会展示出，这个视频源的实际视频内容是 MP4 格式的，视频在 0 通道，音频在 1 通道。</p><h5 id="SETUP-请求"><a href="#SETUP-请求" class="headerlink" title="SETUP 请求"></a>SETUP 请求</h5><p>现在，我们到了 SETUP 步骤，相当于初始化（如果播放源既有音频又有视频，那么需要 SETUP 两次）：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036927615614.jpg" alt="SETUP 请求"><br>这里解释下 Transport 的内容：</p><ul><li>  RTP/AVP：表示 RTP A/V Profile，其实后面省略了 UDP，如果是 RTP/AVP/TCP 则表示 RTP 使用 TCP 进行传输；</li><li>  unicast：表示单播，与组播（multicast）进行区别，即一对一进行传输，而不是一对多；</li><li>  client_port=57246-57247：表示客户端打开了 57246 以及 57247 端口，分别进行 RTP 以及 RTSP 进行数据传输；</li></ul><p>记下来就是服务端回应：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036928151218.jpg" alt="SETUP 回复"></p><p>这里需要注意下 Session，这是接下来的播放控制请求都会带上的，用来区别不同的播放请求。</p><h5 id="PLAY-请求"><a href="#PLAY-请求" class="headerlink" title="PLAY 请求"></a>PLAY 请求</h5><p>接下来就是正式的请求了：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036928328995.jpg" alt="PLAY 请求"></p><p>其中的 Range 表示播放时间的范围，而上图的 <code>npt=0.000-</code> 表示这是一个实时的视频源。</p><p>服务端会回应一个带有 RTP-Info 的头，其中的 seq 以及 rtptime 的信息都用来指示 RTP 包的信息。</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036928562414.jpg" alt="PLAY 回复"></p><p>如果你注意下上面的总览，你会发现服务端在接收到 PLAY 请求的同时，就开啊是发送 RTP 以及 RTCP 数据进行真正的播放了。</p><h5 id="TEARDOWN-请求"><a href="#TEARDOWN-请求" class="headerlink" title="TEARDOWN 请求"></a>TEARDOWN 请求</h5><p>即停止播放请求，这里很简单，就不详述了。</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16037043429830.jpg" alt="TEARDOWN 请求"></p><p><img src="https://blog.xizhibei.me/media/16031752728797/16037043599550.jpg" alt="TEARDOWN 回复"></p><h4 id="RTCP-协议"><a href="#RTCP-协议" class="headerlink" title="RTCP 协议"></a>RTCP 协议</h4><p>相比于 RTSP 的 文本协议，RTCP 属于二进制协议，它的协议头如下<sup><a href="https://en.wikipedia.org/wiki/RTP_Control_Protocol">2</a></sup>：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036940344086.jpg" alt="RTCP"></p><ol><li> Version: 版本号，与 RTP 中的版本号一致，目前为 2；</li><li> P (Padding): 用来表示 RTP 包是否包含填充字节（比如加密的 RTP 包会用到）；</li><li> RC (Reception report count): 统计信息，接收</li><li> PT (Packet type) : 包的类型，目前有发送者报告（SR）、接收者报告（RR）、SDES（源描述）、BYE（结束）、APP（应用自定义）；</li><li> Length: 当前包的长度；</li><li> SSRC: 同步源标识；</li></ol><p>拿出实际例子，我们会发现服务端接受到 PLAY 请求后，紧接着就发送了一个 RTCP Sender Report：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16036935371953.jpg" alt="RTCP"></p><p>从中需要注意的一点在于，它有两个时间戳，一个是 NTP (Network Time Protocol) 时间戳，用 8 个字节来表示的绝对时间，另一个则是 RTP 时间戳，这是相对时间，可以用来计算 RTP 包的时间，具体的计算规则是用两个 RTP 时间戳的差值除以视频采样频率，再加上这里的绝对时间，就是当前 RTP 包的绝对时间了。（不知道采样频率？回头去看看上面 RTSP 的 DESCRIBE 请求的回复。）</p><h3 id="RTP-协议"><a href="#RTP-协议" class="headerlink" title="RTP 协议"></a>RTP 协议</h3><p>RTP 也属于二进制协议，它的协议头如下<sup><a href="https://en.wikipedia.org/wiki/Real-time_Transport_Protocol">1</a></sup>：</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16037029014375.jpg" alt="RTP"></p><ol><li> Version: 版本号，同 RTCP；</li><li> P (Padding): 同 RTCP；</li><li> X (Extension): 表示是否有拓展包头；</li><li> CC (CSRC count): CSRC 个数；</li><li> M (Marker): 标志位，比如可以用来标志视频帧的边界；</li><li> PT (Payload type): 包内容类型，具体类型非常多，想了解的可以看 <a href="https://tools.ietf.org/html/rfc3551">rfc3551</a>；</li><li> Sequence number: 序号，防止丢包以及包乱序；</li><li> Timestamp: 时间戳，与上面 RTCP 时间戳相关；</li><li> SSRC: 同步源标识；</li><li>CSRC: 贡献源标识；</li><li>Header extension: 可拓展的包头；</li></ol><p>我们选取第一个 RTP 包来看，我们可以看到，内容类型是 96，也就是 H264。</p><p><img src="https://blog.xizhibei.me/media/16031752728797/16037061301231.jpg" alt="RTP"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RTSP 协议本身不复杂，下一篇我们来说说关于 RTSP 的实践。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://en.wikipedia.org/wiki/Real-time_Transport_Protocol">Real-time Transport Protocol</a></li><li> <a href="https://en.wikipedia.org/wiki/RTP_Control_Protocol">RTP Control Protocol</a></li><li> <a href="https://en.wikipedia.org/wiki/Session_Description_Protocol">Session Description Protocol</a></li><li> <a href="https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol">Real Time Streaming Protocol</a></li><li> <a href="https://tools.ietf.org/html/rfc2326">rfc2326 Real Time Streaming Protocol (RTSP)</a></li><li> <a href="https://tools.ietf.org/html/rfc3550">rfc3550 RTP: A Transport Protocol for Real-Time Applications</a></li><li> <a href="https://tools.ietf.org/html/rfc3551">rfc3551 RTP Profile for Audio and Video Conferences with Minimal Control</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/152">https://github.com/xizhibei/blog/issues/152</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/10/26/rtsp-explain/" target="_blank">https://blog.xizhibei.me/2020/10/26/rtsp-explain/</a></b><br/><hr>]]></content>
    
    
    <summary type="html">&lt;!-- en_title: rtsp-explain --&gt;

&lt;p&gt;当我们谈到 RTSP 的时候，其实不仅仅是 RTSP 协议本身，我们其实不可避免会谈到以下几个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  RTP (Real-time Transport Protocol)：真正用来传输音频视频的协议，一般是建立在 UDP 协议的基础上，特别需要注意的是，它使用偶数端口&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real-time_Transport_Protocol&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;li&gt;  RTCP (Real-time Control Protocol)：RTP 的姊妹协议，通过周期性发送统计信息，提供服务质量（QoS）的反馈，它使用的端口是奇数，而且就是 RTP 端口 +1&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/RTP_Control_Protocol&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;li&gt;  SDP (Session Description Protocol)：是应用层的一个协议，也可以说事一个格式，跟 HTML、JSON 之类的算是同一类（在今天的文章里就简单带过了）&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Session_Description_Protocol&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="视频直播" scheme="https://blog.xizhibei.me/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>北疆（新疆）自驾游记</title>
    <link href="https://blog.xizhibei.me/2020/10/19/a-self-driving-tour-to-northern-xinjiang/"/>
    <id>https://blog.xizhibei.me/2020/10/19/a-self-driving-tour-to-northern-xinjiang/</id>
    <published>2020-10-19T04:49:16.000Z</published>
    <updated>2021-05-01T15:35:48.461Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: a-self-driving-tour-to-northern-xinjiang --><p>国庆去了新疆玩，这么多天过去了，一直在搞租房的事情，这把我搞得很烦闷，今天终于搞定了，心静下来了，聊点闲事（显然是我没有其它可以写的）。</p><a id="more"></a><p>拿出照片回味了一阵，想起了大美的新疆，当然还有各种甜甜的葡萄、羊肉串、大块的羊排、牛肉、奶啤。在那几天几乎每天都在开车自驾（其实也算是练车了），整个旅游期间自己差不多开了 2000 公里，车技有所提升（其实我应该好好感谢老天，没让我在路上发生什么车祸啥的）。</p><p>在这个不平静的 2020 年，新疆自驾算是我终于出去放飞了。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>新疆是我国边陲省份，极富异域特色，我最初想去玩的动力来自于各种风光大片，那里的景色实在太美，而且还有各种好吃好喝的：9 月不仅是牛羊最肥的时候，各种瓜果也是最甜的。</p><p>新疆的景点非常多，其中以天山山脉为界，分为北疆与南疆：北疆以自然风光为主，最佳旅行时间 6-9 月（实际上 6-8 月适合草原景色，9 月的草原基本上开始枯黄）；而南疆则以人文风情为主，最佳旅行时间 8-10 月。</p><p>下面是一张网上盗来的图（来自<a href="http://www.mafengwo.cn/i/20103979.html">马蜂窝的游记</a>），基本上把整个新疆的景点都囊括进去了。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/16022243325956.jpg" alt="南北疆旅游路线示意图"></p><p>我这次旅行的主要行程是在北疆，重点是喀纳斯，因为那个地方就包括了三个重要景点：贾登峪、禾木以及白哈巴，剩余的景点并没有抱太多的期待。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为了这次自驾旅行，我差不多提前了半个月的时间开始准备，包括各种行程计划以及物资，显然，准备不够充分：行程安排过于紧凑，没有足够的时间来静静地欣赏新疆的美。</p><p>这次我准备的时间有 9 天，以为时间是足够的，于是行程就安排成了如下：</p><ol><li> 乌鲁木齐，布尔津，五彩滩</li><li> 布尔津，禾木</li><li> 禾木，贾登峪（喀纳斯景区内部）</li><li> 白哈巴</li><li> 贾登峪，克拉玛依（魔鬼城），奎屯</li><li> 赛里木湖</li><li> 那提拉草原，巴音布鲁克草原</li><li> 独库公路，奎屯</li><li> 乌鲁木齐</li></ol><p>期间与同行的伙伴讨论了不少，考虑到独库公路的不确定性，我们把独库公路作为一个关键变量，后期灵活调整路线，也没有提前预定酒店之类的。</p><p>而实际上，我们的行程中，由于每个地点之间安排的时间较少，导致我们一旦某个景点花费时间多了，就会影响到下一个行程，也就是预留时间太少了。</p><p>于是，我们裁剪了不少行程，实际行程如下：</p><ol><li> 乌鲁木齐，布尔津</li><li> 布尔津，禾木</li><li> 禾木，贾登峪（喀纳斯景区内部）</li><li> 贾登峪，布尔津，五彩滩</li><li> 布尔津，克拉玛依（魔鬼城），奎屯</li><li> 独库公路，那提拉草原</li><li> 伊宁（之前没有放到行程中，临时改的）</li><li> 赛里木湖</li><li> 乌鲁木齐</li></ol><h3 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h3><h5 id="路上的风景"><a href="#路上的风景" class="headerlink" title="路上的风景"></a>路上的风景</h5><p><img src="https://blog.xizhibei.me/media/16021537570609/F264A137-619D-4549-9883-D6834526B24F_1_105_c.jpeg" alt="路上的风景"></p><h5 id="禾木村"><a href="#禾木村" class="headerlink" title="禾木村"></a>禾木村</h5><p>日出，为了看日出，6 点起床，由于实际的时差，相当于内地 4 点了，冻得我一路上都在靠抖来保暖，不过看到了日出后的村子还是觉得很值得的。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/39299C1F-C1B9-4A84-B380-0C9502B91039_1_105_c.jpeg" alt="禾木村日出 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/8AF9B559-6AAC-4015-90EB-E0769BED7A23_1_105_c.jpeg" alt="禾木村日出 2"><br><img src="https://blog.xizhibei.me/media/16021537570609/F7E3826B-062B-405E-BA1B-5CAE733824CA_1_105_c.jpeg" alt="禾木村日出 3"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/083F6F3A-9889-492D-94B5-13E647BD3D39_1_105_c.jpeg" alt="禾木村，吊桥"></p><h5 id="喀纳斯"><a href="#喀纳斯" class="headerlink" title="喀纳斯"></a>喀纳斯</h5><p>到了喀纳斯后，就直接开始欣赏三个湾，比较可惜的是，月亮湾由于时间关系就错过了。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/231418E0-CC32-4DCE-A269-AD71686BECF3_1_105_c.jpeg" alt="卧龙湾"></p><p>老村早上起来就下雪了，让我感觉好幸运。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/8C80D899-3597-4B45-BB85-F44A06098675_1_105_c.jpeg" alt="喀纳斯老村 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/D7A9DBA1-5A43-4CBC-8BA1-D97209861689_1_105_c.jpeg" alt="喀纳斯老村 2"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/3A90B641-E378-4896-8745-8A5AC939F2DB_1_105_c.jpeg" alt="喀纳斯湖 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/EFFA64B7-E55E-403A-96FE-76131D895127_1_105_c.jpeg" alt="喀纳斯湖 2"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/7FF8BAE3-EDA6-467F-BD8E-12758F708BF4_1_105_c.jpeg" alt="喀纳斯湖 3"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/062A4E53-1A0D-443B-8193-67AEC3927EB3_1_105_c.jpeg" alt="喀纳斯湖 4"></p><h3 id="布尔津"><a href="#布尔津" class="headerlink" title="布尔津"></a>布尔津</h3><p>在回布尔津的路上，觉得风景不错，就停下来了，算是自驾游的乐趣之一了（也是错过景点的原因）。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/FD66D782-31FC-4505-B39D-74ABAC68BA71_1_105_c.jpeg" alt="回布尔津的路上"></p><p>在傍晚时分，赶上了五彩滩的日落（不过，还是觉得看不够）。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/0B541FA8-8133-4E4C-B0CE-BB32C1AEEFD4_1_105_c.jpeg" alt="五彩滩"></p><h5 id="克拉玛依魔鬼城"><a href="#克拉玛依魔鬼城" class="headerlink" title="克拉玛依魔鬼城"></a>克拉玛依魔鬼城</h5><p>第二天赶得急，中午路过魔鬼城，没法在日落时欣赏，就简单打卡了。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/B69CFC28-A18F-4659-8F2E-B2E945FDD13C_1_105_c.jpeg" alt="魔鬼城 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/12492592-1D02-402C-B4E9-6086FD7AD9DE_1_105_c.jpeg" alt="魔鬼城 2"></p><h5 id="独库公路"><a href="#独库公路" class="headerlink" title="独库公路"></a>独库公路</h5><p>独库公路其实并没有特别棒的风光，只是在这旅途中感受到四季的变换还是很震撼的，也可能是因为只走了北段，整段体验并不是很好，只是路上如果能一路拍视频下来，效果还是不错的。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/5DA7338E-3B51-4B39-BA56-5DD4D7321AB7_1_105_c.jpeg" alt="独库公路 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/C25E3BF9-FAFD-4DC5-BF30-186A8741E22C_1_105_c.jpeg" alt="独库公路 2"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/59F51C41-7AC3-4FDC-942A-E755515CCDBE_1_105_c.jpeg" alt="独库公路 3"></p><h5 id="那拉提草原"><a href="#那拉提草原" class="headerlink" title="那拉提草原"></a>那拉提草原</h5><p>从独库公路下来，就直奔那拉提草原，只是路上被一辆逆行的车刮擦了后视镜，那辆车直接逃逸，但是我们报警处理后等了很久也没消息，更糟糕的是错过了欣赏草原的时间，离日落还有一个小时的时候开始逛草原。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/3F68A2AE-4BCD-422B-AAFB-F2D338E94663_1_105_c.jpeg" alt="那拉提草原 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/8D20018F-650F-45FA-AB1F-7A64B8B22AEA_1_105_c.jpeg" alt="那拉提草原 2"></p><h5 id="伊宁"><a href="#伊宁" class="headerlink" title="伊宁"></a>伊宁</h5><p>临时决定去的伊宁算是我们的头脑一热的结果，但是在伊宁感受到的人文风情算是稍稍领略了南疆的特色（下次打算直接去南疆了）。</p><p>到了伊宁之后，我们就决定吃顿好的，天天在路上啃面包算是怎么回事，于是就去喀赞其民俗村里面，找到了这家餐厅，评价非常高，东西也好吃，那天吃肉吃到饱，到了晚上 11 点都不饿。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/0CF47327-A91B-467C-A29A-9F83A0666F0A_1_105_c.jpeg" alt="喀赞其民俗村餐厅 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/5F92873A-710D-4593-BE14-2358DB3E0961_1_105_c.jpeg" alt="喀赞其民俗村餐厅 2"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/7D4576E1-2F00-4A43-8C94-530274384B7B_1_105_c.jpeg" alt="喀赞其民俗村餐厅 3"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/0457AEF8-E67A-4791-AE11-99CF34717BC4_1_105_c.jpeg" alt="喀赞其民俗村餐厅 4"></p><p>吃完就开始逛喀赞其民俗村，这个村子的魅力就在各个小巷子里面。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/99797464-627B-4356-B87A-1979661CA93F_1_105_c.jpeg" alt="喀赞其民俗村 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/671C81D2-5472-4EFA-80AE-7E12CF289934_1_105_c.jpeg" alt="喀赞其民俗村 2"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/5482A3D1-5FA4-41F1-B252-6B2981737817_1_105_c.jpeg" alt="喀赞其民俗村 3"></p><h5 id="赛里木湖"><a href="#赛里木湖" class="headerlink" title="赛里木湖"></a>赛里木湖</h5><p>赛里木湖这是整个旅程中，最后一个自然风光景点了。让我们停满意的地方在于，在这里我们可以自驾环湖。</p><p><img src="https://blog.xizhibei.me/media/16021537570609/C527B4EF-C6AB-4E1D-9D2A-0C5F29A418D0_1_105_c.jpeg" alt="赛里木湖 1"></p><p><img src="https://blog.xizhibei.me/media/16021537570609/880E0FC9-EB94-44A9-B829-79A7CF608844_1_105_c.jpeg" alt="赛里木湖 2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>新疆非常值得多玩几次，也值得多花点时间来静静欣赏。</p><ol><li> 租个无人机体验会好很多；</li><li> 自驾的时候最好在车前绑个运动相机，这样整个路上的美景都能记录下来；</li><li> 行程安排过于紧凑，没有足够的时间来静静地欣赏新疆的美（其实还是假期太短 😂 ）；</li></ol><p>如果能够重新安排，我想，整个过程或许只玩喀纳斯就足够了，比如可可托海以及白哈巴都可以加到行程里面。</p><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/151">https://github.com/xizhibei/blog/issues/151</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/10/19/a-self-driving-tour-to-northern-xinjiang/" target="_blank">https://blog.xizhibei.me/2020/10/19/a-self-driving-tour-to-northern-xinjiang/</a></b><br/><hr>]]></content>
    
    
    <summary type="html">&lt;!-- en_title: a-self-driving-tour-to-northern-xinjiang --&gt;

&lt;p&gt;国庆去了新疆玩，这么多天过去了，一直在搞租房的事情，这把我搞得很烦闷，今天终于搞定了，心静下来了，聊点闲事（显然是我没有其它可以写的）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="旅行" scheme="https://blog.xizhibei.me/tags/%E6%97%85%E8%A1%8C/"/>
    
    <category term="生活" scheme="https://blog.xizhibei.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中的 Unicode 与 UTF-8</title>
    <link href="https://blog.xizhibei.me/2020/09/18/golang-unicode-utf8/"/>
    <id>https://blog.xizhibei.me/2020/09/18/golang-unicode-utf8/</id>
    <published>2020-09-18T06:50:09.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: golang-unicode-utf8 --><p>大多数的我们，真正认识到有字符编码这回事，一般都是因为遇到了乱码，因为我国常用的编码是 GBK 以及 GB2312：用两个 Byte 来表示所有的汉字，这样，我们一共可以表示 2^16 = 65536 个字符，一旦我们的 GBK 以及 GB2312 编码遇到了其他编码，比如日本，韩国的编码，就会变成乱码，当然，这时候如果是 UTF-8，也会乱码。</p><a id="more"></a><p>我们知道，在计算机内部，为了把二进制数据转换为显示器上，需要进行编码，即将可显示的字符一一对应到二进制数据上，比如 ASCII 码，就是用一个 Byte 的数据来表示英文字符加上一些英文符号。</p><p>至于中文，我们显然不能使用仅仅一个 Byte 来表示，我们需要用到更大的空间。</p><h3 id="Unicode-与-Code-point"><a href="#Unicode-与-Code-point" class="headerlink" title="Unicode 与 Code point"></a>Unicode 与 Code point</h3><p>在如今这个小小的世界村里，有着那么多的语言与文字，为了兼容所有的字符，Unicode 出现了，但是它需要有更多的 Byte 来将这个世界上所有的字符收纳进去（这里面甚至包含了 <a href="https://unicode.org/emoji/charts/full-emoji-list.html">Emoji</a>）。</p><p>为了了解 Unicode，你需要了解 Code point 即所谓的码点，也就是用 4 个 Byte 大小的数字来表示所有的字符。</p><p>至于 Unicode 本身，你可以认为它就是 Code point 的集合，而 UTF-8 呢？就是 Unicode 的编码方式。</p><h3 id="Unicode-与-UTF-8-编码"><a href="#Unicode-与-UTF-8-编码" class="headerlink" title="Unicode 与 UTF-8 编码"></a>Unicode 与 UTF-8 编码</h3><p>下面的图来自 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 的截图：<br><img src="https://blog.xizhibei.me/media/15988590105762/16003987212676.jpg" alt="UTF-8 layout"></p><p>这幅图简单明了的告诉我们，UTF-8 的编码方式，比如汉字一般用三个 Byte，每个 Byte 的开头都是固定的，各种文字软件解析 UTF-8 编码的时候，它就会按照这个格式去解析，一旦解析错误（毕竟还可能会有不符合要求的数据，或者是文件错误了），错误的字节就会被替换为 “�” (U+FFFD)，然后神奇的地方就来了：<strong>即使遇到这种错误，它也不会影响接下来的其他字符的解析</strong>，因为这种编码不必从头开始，使得它可以<strong>自我同步（Self-synchronizing）</strong>。与此同时，其它的一些编码一旦遇到错误编码就会出问题，导致错误编码之后的正确编码也会跟着出错。</p><p>当然，UTF-8 编码也有缺点，由于它是可变的，当英文字符偏多的时候，它会省空间，然而比如当中文偏多的时候，它理论上（3 Byte）会比 GBK 编码（2 Byte）最多多出 1/3 的存储空间。</p><h4 id="UTF-8-的例子"><a href="#UTF-8-的例子" class="headerlink" title="UTF-8 的例子"></a>UTF-8 的例子</h4><p>我们拿 Unicode 中最受欢迎的 Emoji 表情 😂 <sup><a href="https://home.unicode.org/emoji/emoji-frequency/">1</a></sup> 来举例：它的 Code point 是 <code>U+1F602</code>（对，<code>1F602</code> 是以 16 进制表示的），然而在内存中它的存储方式的却是 <code>0xf09f9882</code>，为什么？这就是 UTF-8 的编码了（注意对比上图的编码方式）：</p><pre><code>     000    011111    011000    000010 1f60211110000  10011111  10011000  10000010 f0 9f 98 82</code></pre><p>通过把 UTF-8 的编码格子里面数据提取出来，我们就能获得 Code point <code>1F602</code>。</p><p>你也可以用 Golang 来查看其它字符的编码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, []<span class="keyword">byte</span>(<span class="string">`😂`</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;% x\n&quot;</span>, []<span class="keyword">byte</span>(<span class="string">`😂`</span>))</span><br><span class="line"></span><br><span class="line">r, _ := utf8.DecodeRuneInString(<span class="string">`😂`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;% b\n&quot;</span>, r)</span><br><span class="line">fmt.Printf(<span class="string">&quot;% x\n&quot;</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unicode-的其他编码"><a href="#Unicode-的其他编码" class="headerlink" title="Unicode 的其他编码"></a>Unicode 的其他编码</h3><p>Unicode 当然不止一种编码，还有 UTF-16、UTF-32 等，它们的关系就是 UTF-16 用 2 个 Byte 来表示 UTF-8 分别用 1/2/3 个 Byte 来表示的字符，然后 4 个 Byte 与 UTF-8 一致，UTF-32 是完全用 4 个 Byte 来表示所有的字符，另外，详细的可以在 <a href="https://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings">Comparison of Unicode encodings</a> 中看到，</p><p>好，基础讲完，现在开始正式介绍。</p><h3 id="Unicode-与-Golang-2"><a href="#Unicode-与-Golang-2" class="headerlink" title="Unicode 与 Golang 2"></a>Unicode 与 Golang <sup><a href="https://blog.golang.org/strings">2</a></sup></h3><p>这里特别需要提到的是 Golang 与 UTF-8 的关系，他们背后的男人，都是 Ken Thompson 跟 Rob Pike <sup><a href="https://en.wikipedia.org/wiki/UTF-8">3</a> <a href="https://en.wikipedia.org/wiki/Ken_Thompson">4</a> <a href="https://en.wikipedia.org/wiki/Rob_Pike">5</a></sup>，由此，大家就会明白 Golang 的 UTF-8 设计是有多么重要的参考意义。比如 Golang 设计了一个 <code>rune</code> 类型来取代 Code point 的意义。</p><p>rune 看源码就知道，它就是 int32，刚好 4 个 Byte，刚可以用来表示 Unicode 的所有编码 UTF-8 与 UTF-16。</p><p>在继续之前，我想帮各位明白一个事实：Golang 的源码是默认 UTF-8 编码的，这点从上面我给出的例子中就能明白，所以表情字符在编译的时候，就已经能被解析。</p><p>好了，那么我们来看看 Golang 的 <code>unicode</code> 包，其中就会有很多有用的判断函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsControl</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsDigit</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsGraphic</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsLetter</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsMark</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNumber</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPunct</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSpace</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSymbol</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>另外，在 <code>src/unicode/tables.go</code> 中，有大量的 Unicode 中，各类字符的 Code point 区间，会有比较大的参考价值。</p><p>再看看 <code>unicode/utf8</code> 包，这里面的函数，大多数时候你都用不到，但是有这么几类情况就需要你必须得用到了：</p><ol><li> 统计字符数量；</li><li> 转编码，比如将 GBK 转为 UTF-8；</li><li> 判断字符串是否是 UTF-8 编码，或者是否含有不符合 UTF-8 编码的字符；</li></ol><p>后面两个可以忽略，第一个需要特地提醒下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">`😂`</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))</span><br></pre></td></tr></table></figure><p>这句输出是什么？上面提过了，刚好就是 4。于是，你不能使用 <code>len</code> 来获取字符数量，也就不能以此来判断用户输入的字符是不是超过了系统的限制。另外，你也不能通过 <code>s[0]</code> 这样的方式来获取字符，因为这样你只能取到这 4 个 Byte 中的第一个，也就是 <code>0xf0</code>。</p><p>你应该做的就是把 string 转为 rune 数组，然后再去进行字符的操作。</p><p>具体的使用方法就不细谈了，相信你们能搞定。</p><p>另外，这里需要另外提示下，在 Node.js 中，string 本身就是 Unicode，而不是像 Golang 的 string 是二进制，因此在这里可以认为 Node.js 的 Buffer 才是 Golang 中的 string。</p><p>好了，最后留给你一个思考题：在 Node.js 中，为什么在处理 Buffer 时候，不能直接拼接？</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://home.unicode.org/emoji/emoji-frequency/">Emoji frequency</a></li><li> <a href="https://blog.golang.org/strings">Strings, bytes, runes and characters in Go</a></li><li> <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a></li><li> <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a></li><li> <a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/150">https://github.com/xizhibei/blog/issues/150</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/09/18/golang-unicode-utf8/" target="_blank">https://blog.xizhibei.me/2020/09/18/golang-unicode-utf8/</a></b><br/><hr>]]></content>
    
    
    <summary type="html">&lt;!-- en_title: golang-unicode-utf8 --&gt;

&lt;p&gt;大多数的我们，真正认识到有字符编码这回事，一般都是因为遇到了乱码，因为我国常用的编码是 GBK 以及 GB2312：用两个 Byte 来表示所有的汉字，这样，我们一共可以表示 2^16 = 65536 个字符，一旦我们的 GBK 以及 GB2312 编码遇到了其他编码，比如日本，韩国的编码，就会变成乱码，当然，这时候如果是 UTF-8，也会乱码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://blog.xizhibei.me/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>CMake 系列完结以及一些碎碎念</title>
    <link href="https://blog.xizhibei.me/2020/08/30/finish-of-cmake-and-small-talks/"/>
    <id>https://blog.xizhibei.me/2020/08/30/finish-of-cmake-and-small-talks/</id>
    <published>2020-08-30T08:01:56.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: finish-of-cmake-and-small-talks --><p>这过去的几个月中，我一直在写 CMake 相关的内容，写成了一个系列，到今天，我打算先放下了。</p><p>事实是，我似乎是陷入灵感枯竭期了。</p><h3 id="CMake-系列的总结"><a href="#CMake-系列的总结" class="headerlink" title="CMake 系列的总结"></a>CMake 系列的总结</h3><p>先来做个总结，CMake 系列，一共写了十篇，从基础，到高级内容，基本上都是我在工作中的学习内容，没有很精深，也没有写的很全面，毕竟自己重新写 C++ 也不过这过去不到一年的时间。</p><p>回顾 CMake 系列，我发现写一个系列的话，心理压力会小很多，毕竟题目就限定在一个比较小的范围之内了，内容自然就比较容易写。</p><p>另外就是 CMake 本身也不难，资料以及社区的内容都比较丰富，基本上遇到的问题都能够通过搜索来解决。</p><p>但是，这也带来了问题，因为光顾着写 CMake，没有注意到其它内容的缺失，导致了选题的懒惰，没有去挖掘其它可以写的内容，等 CMake 写到了后期，这种感觉就会非常强烈：要结束了，我该写点什么东西呢？</p><p>再回顾这几年来的博客，发现这些博客基本上就是自己的工作总结了，基本上学到了什么，就会在博客中写什么，所以，看起来，我这过去的几年，学的东西很杂。</p><p>好了，到这里，我认为 CMake 本身算是自己在写长篇内容方面的一次尝试，就这个尝试本身而言，算是自己的成功。</p><h3 id="为什么灵感枯竭"><a href="#为什么灵感枯竭" class="headerlink" title="为什么灵感枯竭"></a>为什么灵感枯竭</h3><p>这次的博客，整整迟到了一周，至于灵感枯竭，我分析了下原因。</p><h4 id="完美心理"><a href="#完美心理" class="headerlink" title="完美心理"></a>完美心理</h4><p>把很久之前写过的文章拿出来，自己看了就会吐槽，写得真烂，但是，当初自己写的时候，并没有那么多的顾虑，篇幅写的小，内容也不多，但写的过程却很轻松，经常是打开网页就能写了。</p><p>现在，心理完全变了，因为偶尔会写出自己都觉得不错的文章，于是，对自己的要求也会变高，那些很水的文章，自己不屑于去写了。</p><p>于是，问题就来了，如果看过我大部分文章，就会发现，目前的更新频率没有变，但是更新的日期却是经常拖了，从前是周六，周日，现在一拖再拖，变成周三了。</p><p>问题是什么呢？完美心理，或者说是拖延心理。</p><p>其实，写自己不屑于去写的东西，并且把内容写好了，写得通俗易懂，照样会是好文章，哪怕是一篇手把手教着小白编程的文章，也会有它的价值所在。</p><h4 id="输入不够"><a href="#输入不够" class="headerlink" title="输入不够"></a>输入不够</h4><p>最近几个月，学习的内容，也变少了，比如技术上就局限在嵌入式、摄像头 ISP 上，一方面是自己不熟悉的内容，另一方面，却是一直在炒冷饭。</p><p>读书也变少了，严格来说，是技术内容变少了，最近看的几本都是金融类、以及小说。</p><p>所以，古人说「读书破万卷，下笔如有神」不是没有道理的。</p><p>因此，书不能停。</p><h3 id="接下来写的预告"><a href="#接下来写的预告" class="headerlink" title="接下来写的预告"></a>接下来写的预告</h3><p>之所会有这个，大概我想通过预告来逼着自己多些点内容，以及看看大家有没有感兴趣的，可以收集点意见。</p><p>目前，我大概有这么几个可以写的：</p><ol><li>技术内容<ol><li> 密码学的基础以及实践</li><li> 数字图像的处理</li><li> Golang 源码的解读</li><li> Linux 工具：iptables、ip、rsync、sed、awk、bash 等</li></ol></li><li>非技术内容<ol><li> 投资理财：股票基金以及债券基金</li><li> 工作效率：GTD 以及 番茄钟</li></ol></li></ol><p>另外，CMake 其实还有内容可写，如果有机会的话：</p><ol><li> CMake 的样例解读 OpenCV</li><li> CMake 偏小方面的知识，如 RPATH、Generator expressions、Policy、Qt</li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/148">https://github.com/xizhibei/blog/issues/148</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/08/30/finish-of-cmake-and-small-talks/" target="_blank">https://blog.xizhibei.me/2020/08/30/finish-of-cmake-and-small-talks/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: finish-of-cmake-and-small-talks --&gt;

&lt;p&gt;这过去的几个月中，我一直在写 CMake 相关的内容，写成了一个系列，到今天，我打算先放下了。&lt;/p&gt;
&lt;p&gt;事实是，我似乎是陷入灵感枯竭期了。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    
    <category term="总结" scheme="https://blog.xizhibei.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>隐私守卫者 PGP</title>
    <link href="https://blog.xizhibei.me/2020/08/12/privacy-guardian-pgp/"/>
    <id>https://blog.xizhibei.me/2020/08/12/privacy-guardian-pgp/</id>
    <published>2020-08-12T07:16:01.000Z</published>
    <updated>2021-05-01T15:35:48.469Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: privacy-guardian-pgp --><p>我第一次提到过 PGP，是在 <a href="https://blog.xizhibei.me/2018/10/27/helm-in-practice-config-management/">Helm 实践之配置管理</a> 以及 <a href="https://blog.xizhibei.me/2018/11/03/helm-in-practice-continue-delivery/">Helm 实践之持续交付</a>  里面，但当时只是提到它可以用来加密我们的配置，但没有拓展它，今天我们来简单拓展下。</p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>菲利普 · 齐默曼（Philip R. Zimmermann）在 1991 年创造了第一个版本的 PGP，其名称 “Pretty Good Privacy”<sup><a href="https://zh.wikipedia.org/wiki/PGP">1</a></sup>。</p><p>显而易见，他发明这东西就是为了对抗政府的监视，一经发出，受到了广泛的欢迎。</p><p>由于这个软件是商业应用，无法大面积推广，后来就出现了 OpenPGP，是一个互联网标准，其中，最著名的莫过于 GunPG，也就是我们的主角 gpg（我在刚使用的时候，经常打错成 pgp）。</p><p>目前 PGP 的作用挺多，主要在于加解密（邮件内容加密）、数字签名（Ubuntu 的软件分发）等。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnupg <span class="comment"># ubuntu</span></span><br><span class="line">brew install gpg <span class="comment"># mac</span></span><br></pre></td></tr></table></figure><p>或者你可以去<a href="https://gnupg.org/">官网</a>下载。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="管理2"><a href="#管理2" class="headerlink" title="管理2"></a>管理<sup><a href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto">2</a></sup></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照步骤，一步一步设置即可，最后的密码不要设置太简单</span></span><br><span class="line">gpg --generate-key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意最后生成的 Key ID，在很多命令中需要用到</span></span><br><span class="line"><span class="comment"># 如果不知道，看看已经生成的密钥</span></span><br><span class="line">gpg --list-keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中那一长串 fingerprint 就是 key ID 了，可以只取最后 8 位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以导出公钥，armor 表示用 ASCII 编码</span></span><br><span class="line">gpg --<span class="built_in">export</span> --armor --output your-name.pub.asc &lt;your-key-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 私钥也可以导出，但是不建议，很容易不小心泄露了</span></span><br><span class="line">gpg --export-secret-keys --output your-name.pri.asc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以发送至远程公钥服务器</span></span><br><span class="line"><span class="comment"># 你的朋友们就可以从服务器获取了</span></span><br><span class="line"><span class="comment"># 之后你可能会收到一份验证邮件，来验证你是这个公钥的持有者</span></span><br><span class="line"><span class="comment"># 其它公钥服务器就不一定会验证了</span></span><br><span class="line">gpg --keyserver hkps://keys.openpgp.org --send-keys &lt;your-key-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如你的密钥泄露了，可以撤消它</span></span><br><span class="line"><span class="comment"># 不要以为撤销就是删除，证书只能追加，</span></span><br><span class="line"><span class="comment"># 因此，你需要生成一个撤销证书来追加到之前的证书中去，</span></span><br><span class="line"><span class="comment"># 合并起来的证书就相当于证书被「撤销」了</span></span><br><span class="line">gpg --gen-revoke &lt;your-key-id&gt; &gt; revoke.asc</span><br><span class="line">gpg --import revoke.asc</span><br><span class="line">gpg --keyserver hkps://keys.openpgp.org --send-keys &lt;your-key-id&gt;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，从公钥服务器获取的证书不一定代表本人，我在上面提到的 keys.openpgp.org 也不一定完全值得信任。</p><p>但是，PGP 区别于 SSL 证书体系的不同就在于此了：它可以由使用者自行决定是否信任中央证书机构，比如你可以由朋友来当这个背书者，即由你的朋友来对新的公钥进行签名认证，从而信任新添加的证书。</p><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><p>首先你需要明白，加密是必须指定接收者的，你必须用朋友的公钥来进行加密，同时，你可以对加密内容进行签名，表示这个加密过的信息，是由你写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加密，会生成一个 mail.txt.asc 的文件，你就可以直接发送给朋友了</span></span><br><span class="line">gpg --armor --sign --recipient &lt;your-friend-id&gt; --encrypt mail.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密，会看到解密后的内容，以及签名是否正确</span></span><br><span class="line">gpg --decrypt mail.txt.asc</span><br></pre></td></tr></table></figure><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>这是对内容的完整性进行保护了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 签名有 clearsign 以及 detach-sign，</span></span><br><span class="line"><span class="comment"># 区别在于前者会在签名文件中带有原文件信息，而后者没有</span></span><br><span class="line"><span class="comment"># 生成的文件依然是以 asc 结尾</span></span><br><span class="line">gpg --armor --detach-sign app.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">gpg --verify app.tgz.asc</span><br></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>实际使用中，会有其它问题，比如，你如何在脚本中使用呢？</p><p>在上面的加密以及签名命令中，你需要用到私钥，因此在 Ubuntu 中你得在弹出的密码框中输入密码，而在脚本中，你是不能这么干的，有其它参数干这个事情。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --batch --yes --passphrase &lt;passphrase&gt; --detach-sign --armor app.tgz</span><br></pre></td></tr></table></figure><p>其中，<code>--passphrase</code> 可以换成 <code>--passphrase-fd</code> 或者 <code>--passphrase-file</code>，来指定密码输入的方式。</p><p>另外，如果你需要直接使用 armor 公钥，一个方式是导入后使用，<code>gpg --import pub.asc</code>，然后对签名进行验证，另一个是需要对公钥的格式进行转换，不然会出错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --yes -o pub.gpg --dearmor pub.asc</span><br><span class="line">gpg --trust-model always --no-default-keyring --keyring pub.gpg --verify app.tgz.asc</span><br></pre></td></tr></table></figure><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://zh.wikipedia.org/wiki/PGP">PGP</a></li><li> <a href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto">GnuPrivacyGuardHowto</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/147">https://github.com/xizhibei/blog/issues/147</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/08/12/privacy-guardian-pgp/" target="_blank">https://blog.xizhibei.me/2020/08/12/privacy-guardian-pgp/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: privacy-guardian-pgp --&gt;

&lt;p&gt;我第一次提到过 PGP，是在 &lt;a href=&quot;https://blog.xizhibei.me/2018/10/27/helm-in-practice-config-management/&quot;</summary>
      
    
    
    
    
    <category term="安全" scheme="https://blog.xizhibei.me/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="工具" scheme="https://blog.xizhibei.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="PGP" scheme="https://blog.xizhibei.me/tags/PGP/"/>
    
  </entry>
  
  <entry>
    <title>【CMake 系列】（十）编译速度以及程序性能优化相关</title>
    <link href="https://blog.xizhibei.me/2020/07/29/cmake-10-refine-compile-speed-and-program-performance/"/>
    <id>https://blog.xizhibei.me/2020/07/29/cmake-10-refine-compile-speed-and-program-performance/</id>
    <published>2020-07-29T09:31:23.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: cmake-10-refine-compile-speed-and-program-performance --><p>写 C/C++ 的同学都知道，项目稍大点，编译速度就开始拖后腿了，这对于我们来说是个又爱又恨的时候：急着改代码的时候，慢能消耗我们的耐心，能将我们逼疯，而我们想暂时休息会儿的时候，却可以借此去散步喝茶了。</p><p>另外，程序运行时的速度，又是另外一个关键的速度了，编译速度慢我们可以忍，但是运行速度慢可忍不了，就算我们忍得了，领导或者用户也是无法忍的。</p><p>话说回来，为了我们自己的开发效率，提升编译速度是无可非议的，今天我们就来说说，如何在 CMake 中优化编译以及以及程序本身。</p><h3 id="编译速度优化"><a href="#编译速度优化" class="headerlink" title="编译速度优化"></a>编译速度优化</h3><h4 id="Ninja-Generator"><a href="#Ninja-Generator" class="headerlink" title="Ninja Generator"></a>Ninja Generator</h4><p>CMake 的默认 Generator 是 Unix Makefiles，也就是最常见的 make 命令，但是另一个 Generator Ninja 却是更好的选择，如果你没有用过，建议试试。</p><h4 id="CCache"><a href="#CCache" class="headerlink" title="CCache"></a>CCache</h4><p>最简单，也是效果最好的，就是开启编译缓存，ccache 便是我们需要的工具。</p><p>它的原理也很简单，就是包装编译器，接收编译参数、文件，当检测到没有对应缓存的时候，调用编译器，将生成物缓存到文件中去，下次如果编译参数以及文件没有变化，就能够直接从缓存文件中提取，这样，就可以大大减少重复编译时候的时间。</p><p>在 CMake 早期版本中 （2.8 Unix Makefiles 以及 3.4 Ninja 之前的版本），没有 ccache 的支持，我们需要手动设置：<code>CMAKE_C_COMPILER</code> 以及 <code>CMAKE_CXX_COMPILER</code>，将 ccache 作为前缀即可：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER ccache gcc)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER ccache g++)</span><br></pre></td></tr></table></figure><p>而另外较新版本中，就更容易了：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_program</span>(CCACHE_PROGRAM ccache)</span><br><span class="line"><span class="keyword">if</span>(CCACHE_PROGRAM)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Set up ccache ...&quot;</span>)</span><br><span class="line">  <span class="keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)</span><br><span class="line">  <span class="keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>然后，XCode generator 可参考 <a href="https://crascit.com/2016/04/09/using-ccache-with-cmake/">Using ccache with CMake</a>。</p><p>或许你会怀疑它究竟有多少效果，下面的结果是我在一台机器上运行 <code>ccache -s</code> 的统计结果：</p><pre><code>cache directory                     /home/me/.ccacheprimary config                      /home/me/.ccache/ccache.confsecondary config      (readonly)    /etc/ccache.confstats zero time                     Tue Apr  7 16:06:27 2020cache hit (direct)                 41056cache hit (preprocessed)            7179cache miss                         25047cache hit rate                     65.82 %called for link                    10928called for preprocessing            5929compile failed                      3055preprocessor error                  1325can&#39;t use precompiled header          86bad compiler arguments                56autoconf compile/link               3428no input file                        616cleanups performed                    90files in cache                     25512cache size                           4.5 GBmax cache size                       5.0 GB</code></pre><p>可以这么说，它在过去几个月的开发过程中，帮我节约了大约 65.82% 的编译时间。</p><h4 id="Precompiled-headers-PCH-以及-Unity-builds2"><a href="#Precompiled-headers-PCH-以及-Unity-builds2" class="headerlink" title="Precompiled headers (PCH) 以及 Unity builds2"></a>Precompiled headers (PCH) 以及 Unity builds<sup><a href="https://onqtam.com/programming/2019-12-20-pch-unity-cmake-3-16/">2</a></sup></h4><p><strong>Precompiled headers</strong>：也就是预编译头，可以大大将少 C++ 头文件的重复编译时间，你可以将一些第三方库，比如 nlohmann/json 、spdlog/spdlog.h、Boost 以及 项目中很少变动的 C++ 头文件加到预编译中：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_precompile_headers(&lt;my_target&gt; PRIVATE my_pch.h)</span><br></pre></td></tr></table></figure><p>但是，生成的中间文件，会非常大，占用比较大的磁盘空间。</p><p><strong>Unity builds</strong>：也可以按照字面意义上去理解，即一体化编译，将多个 CPP 文件合并到一起进行编译，这样的话：编译器可以解析更少的次数、相同模版的优化、更少编译器调用次数、链接器也会更友好。</p><p>使用也很简单：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_UNITY_BUILD <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(&lt;<span class="keyword">target</span>&gt; PROPERTIES UNITY_BUILD <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>然而，这两个算是高级招数，所以不是所有的项目都适合用，没准用了之后会<strong>增加项目的维护成本</strong>，如果不知道怎么用，很可能你用无法编译成功。</p><p>具体的使用，也会挺复杂，有不少的坑，如果各位有兴趣，下次单独讲讲。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>  gcc 换成 clang；</li><li>  静态链接换成动态链接；</li><li>  换台高性能的机器，换个更好的 CPU 以及 SSD 磁盘，甚至用上内存磁盘（这种算是用钱换性能了，但是效果还是非常显著的）；</li></ul><h3 id="程序性能优化"><a href="#程序性能优化" class="headerlink" title="程序性能优化"></a>程序性能优化</h3><p>对于 CMake 来说，最简单优化的莫过于将 Debug 改为 Release 模式。</p><p>另外，就是 <a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">Interprocedural optimization</a>，你可以理解为程序级别的 Release 模式，因为普通的 Release 模式是单个文件级别的。</p><p>当然，不是每个编译器都支持，你需要先检查：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckIPOSupported)</span><br><span class="line">check_ipo_supported(RESULT _IsIPOSupported)</span><br><span class="line">  <span class="keyword">if</span>(_IsIPOSupported)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Turn on INTERPROCEDURAL_OPTIMIZATION&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_INTERPROCEDURAL_OPTIMIZATION <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>其实在性能优化上面，编译器能做的比较有限，更多的还是在于编码阶段，对整个程序的优化。</p><p>而业务逻辑上面，算法上面，等待，都不是编译器能解决的问题，却是能最终影响结果的。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://crascit.com/2016/04/09/using-ccache-with-cmake/">Using ccache with CMake</a></li><li> <a href="https://onqtam.com/programming/2019-12-20-pch-unity-cmake-3-16/">CMake 3.16 added support for precompiled headers &amp; unity builds - what you need to know</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/145">https://github.com/xizhibei/blog/issues/145</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/07/29/cmake-10-refine-compile-speed-and-program-performance/" target="_blank">https://blog.xizhibei.me/2020/07/29/cmake-10-refine-compile-speed-and-program-performance/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: cmake-10-refine-compile-speed-and-program-performance --&gt;

&lt;p&gt;写 C/C++ 的同学都知道，项目稍大点，编译速度就开始拖后腿了，这对于我们来说是个又爱又恨的时候：急着改代码的时候，慢能消耗</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://blog.xizhibei.me/tags/C-C/"/>
    
    <category term="CMake" scheme="https://blog.xizhibei.me/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>为什么你需要理解用户需求</title>
    <link href="https://blog.xizhibei.me/2020/07/14/why-do-you-need-to-understand-user-needs/"/>
    <id>https://blog.xizhibei.me/2020/07/14/why-do-you-need-to-understand-user-needs/</id>
    <published>2020-07-14T11:24:47.000Z</published>
    <updated>2021-05-01T15:35:48.469Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: why-do-you-need-to-understand-user-needs --><p>前些天看到一篇教大家导出百万级别数据 Excel 文件的文章，我当时不由得楞了一会儿：这年头有这样的需求？不过仔细回想之前自己经历过的应用场景，发现还真有。</p><p>撇开技术细节不谈，我们以此来谈谈，作为一个技术人，为什么你需要尝试去理解用户需求。</p><h3 id="从运营同学的导数据需求开始"><a href="#从运营同学的导数据需求开始" class="headerlink" title="从运营同学的导数据需求开始"></a>从运营同学的导数据需求开始</h3><p>假如你做过后端的业务，那么这样类似的数据需求是经常的，比如对于运营同学，他们经常需要你帮忙导数据。</p><p>于是你会发现，一旦你最近做完了某项需求后，紧接着而来的就是运营同学请求你导数据。于是，你需要写一个脚本：连接数据库，读出数据，写入 Excel。</p><p>经历过几次之后，你学乖了，首先是你做成了一个强大的脚本工具，调整下参数就能导出符合要求的 Excel 文件。</p><p>又过了几次，你嫌每次手工调整参数导出很麻烦，而且自己在敲代码的时候也不想被打扰，于是之后每当有新的业务需求来的时候，你会提前跟产品说好，要把数据导出的需求加到需求列表中，还给做了一个漂亮的导出页面，只要在网页上点击几次配置好参数，就能按需导出所需的文件，你几乎觉得完美地解决了运营同学的需求。</p><p>等运营同学再次要求到出数据的时候，你会扔给他管理后台的地址，然后慢悠悠走去茶水间泡一杯咖啡。</p><p>美好的时光总是短暂，终于又有一天，运营再次跑过来，说，导出失败了，你赶紧登陆服务器查看日志，发现是服务器内存太小了，导出的数据直接把内存卡爆了。</p><p>于是，为了让运营同学可以继续导出，你先加大了服务器内存，然后想着怎么解决在小内存服务器上的大数据量导出的问题。查了不少资料，<strong>发现可以利用流的思想，一边从数据库导出，一边写文件到磁盘，这样用小内存也能导出大量的数据</strong>。顺利上线后，运营暂时没有来找自己了。</p><p>安静的时光还是被打破了，运营同学找过来，说还是导出数据的问题，导出的 Excel 文件打不开。你首先怀疑的是对方是不分导出的文件损坏了，你也导出了一份，打开，没问题，你用怜悯的目光盯着运营同学，运营同学急了：「我的电脑上真打不开」，你耐着性子去运营同学的工位上，看着对方双击文件后，Excel 程序启动界面一直处于加载状态，于是，你的微笑逐渐消失，并凝固。打开对方电脑的系统信息，恍然大悟：「你这电脑得换了，才 2G ……」。</p><h3 id="需求已经发生了改变"><a href="#需求已经发生了改变" class="headerlink" title="需求已经发生了改变"></a>需求已经发生了改变</h3><p>到如今，这个问题已经不是普通 PC 能解决的问题了，这其实就是量变带来的质变，你们业务的成长，导致了数据分析成本的上升，那个只靠运营同学用 Excel 手工分析数据的时期已经过去了，你们需要其他方案。</p><p>于是，在搜索了一番之后，你总结了几个方案：</p><h4 id="方案一：换电脑"><a href="#方案一：换电脑" class="headerlink" title="方案一：换电脑"></a>方案一：换电脑</h4><p>内存 16G，CPU 也要升级，不然打开了也会卡顿。</p><p>但换电脑不会那么快，而且也不是所有的公司领导都能批准，因此只能先申请再说。</p><p>另外，就算电脑升级了，到了某个级别后，也无法用升级来解决了。</p><h4 id="方案二：分割"><a href="#方案二：分割" class="headerlink" title="方案二：分割"></a>方案二：分割</h4><p>把一个大的 Excel 文件分割成小文件，导出的时候限制行数，定一个刚好不会卡住的数据量，超过就分割成多个小文件。</p><p>这个方案的好处在于可以用普通 PC 达到部分的数据分析需求，只要磁盘够大，就能分析不少的文件。只是这中方案会限制分析需求，如果遇到复杂的数据分析要求，比如需要的数据分散在不同的文件中，就意味着处理流程会变得很复杂，比如你需要分步骤的多次处理。</p><p>这其实类似于数据库的分片，你只能按照某一个维度去分割，而带来的副作用便是其他维度的碎片化，即当你需要其他维度的聚合分析的时候，处理成本会相应地提高很多。</p><p>如果你知道 Map Reduce，那么你就会知道，这个方案的开发成本会很高，也不是你加上运营同学在短期就能搞定的事情。</p><h4 id="方案三：换软件或者人"><a href="#方案三：换软件或者人" class="headerlink" title="方案三：换软件或者人"></a>方案三：换软件或者人</h4><p>教运营同学学会使用 SPSS/SAS，还有各种线上的数据服务，甚至学 SQL、Python 或着 R ，然后在普通电脑也能分析导出的数据。</p><p>这个方案需要给运营培训了，一时半会儿也教不会，如果能短时间教会，那么你可以改行做培训了。</p><p>或者公司有钱的情况下，招几个数据分析师，把任务交给他们，也能解决问题，你就能专心写自己的业务去了。（当然了，另外需求也会有，你需要把数据以其它形式传给他们，这时候千万别偷懒直接把数据库的用户名密码给他们，万一他们搞出事情来，背锅的可能就是你了。）</p><h3 id="回到需求本身"><a href="#回到需求本身" class="headerlink" title="回到需求本身"></a>回到需求本身</h3><p>到这里，不知你有没有去思考运营同学的需求本身的问题，当他提出导出数据的时候，他真正需要的只是导出数据吗？</p><p>显然不是，他的需求是<strong>根据线上产生的数据，写出可以拿给领导看的报告</strong>。</p><p>所以，我在这里写的第一篇博客，说的就是数据导出的问题：<a href="https://blog.xizhibei.me/2016/04/13/elk-da-jian-liang-san-shi-zhi-shu-ju-xu-qiu/">ELK 搭建两三事之数据需求</a> ，当时的想法目前看来就是个中等数据量的导出需求。</p><p>这其实已经初具数据分析系统的雏形了，因为当时我采取的方案是把线上的数据直接导入 ES 集群，并利用 它的分析能力，再加上 Kibana 提供的 UI，这么个简单的数据分析系统，在较长的一段时间里都满足了运营同学们的需求。</p><p>后来，如果你们的业务进一步成长，带来的数据量也会变成所谓的海量，于是，你们进入到一个新世界，即所谓的「大数据」，在这个新世界里面：</p><ol><li> 数据量从 M，G 变成了 T，P，E ……；</li><li> 涉及的机器从一台 PC 变成了一个，甚至多个数据中心；</li><li> 处理工具从 Excel，SPAS/SAS 变成 Hadoop、Spark、Storm ……；</li><li> 人员从一个开发 + 运营变成了一个 BI 部门；</li></ol><p>一个导数据的需求，会慢慢演变成需要一个部门去解决，这其中经历可不止一次的质变，假如有机会经历这样的演变，相信对于你会是个非常拿的出手的经历。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>那，如何理解用户需求？很遗憾，我也只是个初学者，只是，你可以从思考他们背后的需求开始，比如著名的 X-Y 问题<sup><a href="https://coolshell.cn/articles/10804.html">1</a></sup>。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol><li> <a href="https://coolshell.cn/articles/10804.html">X-Y PROBLEM</a></li></ol><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/143">https://github.com/xizhibei/blog/issues/143</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/07/14/why-do-you-need-to-understand-user-needs/" target="_blank">https://blog.xizhibei.me/2020/07/14/why-do-you-need-to-understand-user-needs/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: why-do-you-need-to-understand-user-needs --&gt;

&lt;p&gt;前些天看到一篇教大家导出百万级别数据 Excel 文件的文章，我当时不由得楞了一会儿：这年头有这样的需求？不过仔细回想之前自己经历过的应用场景，发现还真</summary>
      
    
    
    
    
    <category term="工作方法" scheme="https://blog.xizhibei.me/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    
    <category term="业务" scheme="https://blog.xizhibei.me/tags/%E4%B8%9A%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>【CMake 系列】（九）实战之如何下载依赖</title>
    <link href="https://blog.xizhibei.me/2020/06/30/cmake-9-implement-download-extract-file/"/>
    <id>https://blog.xizhibei.me/2020/06/30/cmake-9-implement-download-extract-file/</id>
    <published>2020-06-30T11:35:08.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: cmake-9-implement-download-extract-file --><p>今天补下之前在 <a href="https://blog.xizhibei.me/2020/03/23/cmake-3-external-project-practise/">ExternalProject 实践</a> 留下的坑：如何下载第三方依赖。</p><h3 id="理清需求"><a href="#理清需求" class="headerlink" title="理清需求"></a>理清需求</h3><p>由于大家的需求很可能是不一致的，这里选一个比较通用的需求：下载第三方依赖压缩包，于是我们就需要下载压缩包文件到本地，验证文件签名，然后解压到指定目录。</p><h3 id="CMake-提供的命令"><a href="#CMake-提供的命令" class="headerlink" title="CMake 提供的命令"></a>CMake 提供的命令</h3><p>我们要用到主要有以下两个命令：</p><ul><li>file<ul><li>  DOWNLOAD：下载文件</li><li>  INSTALL：安装文件到目录</li><li>  READ：读取文件内容</li><li>  REMOVE：删除文件</li><li>  REMOVE_RECURSE：递归删除文件</li><li>  MAKE_DIRECTORY：创建目录</li></ul></li><li>  cmake_parse_arguments：解析传入的函数参数</li><li>  execute_process：运行外部命令（这里需要注意的是，外部命令很有可能运行在不同的操作系统，因此，尽量使用 CMake 提供的命令，这样可以在各个平台都能运行。）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>接下来我们一步步把功能实现。</p><h4 id="下载功能"><a href="#下载功能" class="headerlink" title="下载功能"></a>下载功能</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(download_file url filename)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Download to $&#123;filename&#125; ...&quot;</span>)</span><br><span class="line">  <span class="keyword">file</span>(DOWNLOAD <span class="variable">$&#123;url&#125;</span> <span class="variable">$&#123;filename&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>这便是实现了一个最简单的下载函数，我们直接传入链接地址以及文件名即可下载 <code>download_file(&#39;http://example.com/1.zip&#39;, &#39;2.zip&#39;)</code>。</p><p>接下来，我们开始添油加醋，慢慢实现自己的需求。</p><h4 id="文件签名验证"><a href="#文件签名验证" class="headerlink" title="文件签名验证"></a>文件签名验证</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(download_file_with_hash url filename hash_type hash)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Download to $&#123;filename&#125; ...&quot;</span>)</span><br><span class="line">  <span class="keyword">file</span>(DOWNLOAD <span class="variable">$&#123;url&#125;</span> <span class="variable">$&#123;filename&#125;</span> EXPECTED_HASH <span class="variable">$&#123;hash_type&#125;</span>=<span class="variable">$&#123;hash&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>于是，调用方式变为 <code>download_file_with_hash(&#39;http://example.com/1.zip&#39;, &#39;2.zip&#39;, &#39;SHA1&#39;, &#39;xxxxxxxxxxxxxxx&#39;)</code>。</p><h4 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(extract_file filename extract_dir)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Extract to $&#123;extract_dir&#125; ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 创建临时目录，用来解压，如果已经存在，则删除</span></span><br><span class="line">  <span class="comment"># 这里用的解压命令，是 cmake 内部实现的解压命令，可以实现跨平台解压：</span></span><br><span class="line">  <span class="comment"># cmake -E tar -xf filename.tgz</span></span><br><span class="line">  <span class="keyword">set</span>(temp_dir <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/tmp_for_extract.dir)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="variable">$&#123;temp_dir&#125;</span>)</span><br><span class="line">    <span class="keyword">file</span>(REMOVE_RECURSE <span class="variable">$&#123;temp_dir&#125;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;temp_dir&#125;</span>)</span><br><span class="line">  <span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar -xf <span class="variable">$&#123;filename&#125;</span></span><br><span class="line">                  WORKING_DIRECTORY <span class="variable">$&#123;temp_dir&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 这里比较关键，解压之后的临时目录中，可能是单个文件夹，里面包含着我们需要的内容，</span></span><br><span class="line">  <span class="comment"># 也可能是直接就包含着我们需要的内容，因此，这里就统一处理，如果包含单独的文件夹</span></span><br><span class="line">  <span class="comment"># 则将安装源目录设置为临时目录的下级目录</span></span><br><span class="line">  <span class="keyword">file</span>(GLOB contents <span class="string">&quot;$&#123;temp_dir&#125;/*&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(LENGTH contents n)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> n <span class="keyword">EQUAL</span> <span class="number">1</span> <span class="keyword">OR</span> <span class="keyword">NOT</span> <span class="keyword">IS_DIRECTORY</span> <span class="string">&quot;$&#123;contents&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(contents <span class="string">&quot;$&#123;temp_dir&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get_filename_component</span>(contents <span class="variable">$&#123;contents&#125;</span> ABSOLUTE)</span><br><span class="line">  <span class="comment"># 这里选择 INSTALL 而不是 COPY，因为可以打印出文件拷贝的状态</span></span><br><span class="line">  <span class="keyword">file</span>(<span class="keyword">INSTALL</span> <span class="string">&quot;$&#123;contents&#125;/&quot;</span> DESTINATION <span class="variable">$&#123;extract_dir&#125;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 别忘删除临时目录</span></span><br><span class="line">  <span class="keyword">file</span>(REMOVE_RECURSE <span class="variable">$&#123;temp_dir&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><h4 id="下载后解压"><a href="#下载后解压" class="headerlink" title="下载后解压"></a>下载后解压</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">download_file(&#x27;http://example.com/<span class="number">1</span>.zip&#x27;, &#x27;<span class="number">2</span>.zip&#x27;, &#x27;SHA1&#x27;, &#x27;xxxxxxxxxxxxxxx&#x27;)</span><br><span class="line">extract_file(&#x27;<span class="number">2</span>.zip&#x27;, &#x27;/path/to/<span class="keyword">install</span>&#x27;)</span><br></pre></td></tr></table></figure><p>是不是很简单？现在我们加入更多的功能。</p><h4 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h4><p>很多时候，如果下载的文件存在，我们只需要验证它的签名即可，即我们不用重复下载。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="variable">$&#123;filename&#125;</span>)</span><br><span class="line">    <span class="comment"># 获取文件真实 HASH</span></span><br><span class="line">    <span class="keyword">file</span>(<span class="variable">$&#123;hash_type&#125;</span> <span class="variable">$&#123;filename&#125;</span> _ACTUAL_CHKSUM)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">NOT</span> (<span class="variable">$&#123;hash&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;_ACTUAL_CHKSUM&#125;</span>))</span><br><span class="line">      <span class="comment"># 如果签名不一致，则还是需要重新下载文件</span></span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;Expect $&#123;DAE_HASH_TYPE&#125;=$&#123;_EXPECT_HASH&#125;&quot;</span>)</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;Actual $&#123;DAE_HASH_TYPE&#125;=$&#123;_ACTUAL_CHKSUM&#125;&quot;</span>)</span><br><span class="line">      <span class="keyword">message</span>(WARNING <span class="string">&quot;File hash mismatch, remove &amp; retry ...&quot;</span>)</span><br><span class="line">      <span class="keyword">file</span>(<span class="keyword">REMOVE</span> <span class="variable">$&#123;filename&#125;</span>)</span><br><span class="line">      download_file_with_hash(<span class="variable">$&#123;url&#125;</span> <span class="variable">$&#123;filename&#125;</span> <span class="variable">$&#123;hash_type&#125;</span> <span class="variable">$&#123;hash&#125;</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;Using exists local file $&#123;filename&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    download_file_with_hash(<span class="variable">$&#123;url&#125;</span> <span class="variable">$&#123;filename&#125;</span> <span class="variable">$&#123;hash_type&#125;</span> <span class="variable">$&#123;hash&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>最后，我们将这个过程封装成一个单独的函数，并且加上参数解析。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(download_and_extract)</span><br><span class="line">  <span class="keyword">set</span>(options REMOVE_EXTRACT_DIR_IF_EXISTS)</span><br><span class="line">  <span class="keyword">set</span>(oneValueArgs DESTINATION RENAME)</span><br><span class="line">  <span class="keyword">set</span>(multiValueArgs)</span><br><span class="line">  <span class="keyword">set</span>(oneValueArgs URL FILENAME HASH_TYPE HASH EXTRACT_DIR)</span><br><span class="line">  <span class="keyword">cmake_parse_arguments</span>(DAE <span class="string">&quot;$&#123;options&#125;&quot;</span> <span class="string">&quot;$&#123;oneValueArgs&#125;&quot;</span> <span class="string">&quot;$&#123;multiValueArgs&#125;&quot;</span></span><br><span class="line">                        <span class="variable">$&#123;ARGN&#125;</span>)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> DAE_URL)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Missing URL&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> DAE_FILENAME)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Missing FILENAME&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> DAE_HASH_TYPE)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Missing HASH_TYPE&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> DAE_HASH)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Missing HASH&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> DAE_EXTRACT_DIR)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Missing EXTRACT_DIR&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="variable">$&#123;DAE_EXTRACT_DIR&#125;</span>)</span><br><span class="line">    <span class="keyword">if</span>(DAE_REMOVE_EXTRACT_DIR_IF_EXISTS)</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;DAE_EXTRACT_DIR&#125; already exists, removing...&quot;</span>)</span><br><span class="line">      <span class="keyword">file</span>(REMOVE_RECURSE <span class="variable">$&#123;DAE_EXTRACT_DIR&#125;</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">      <span class="keyword">message</span>(</span><br><span class="line">        STATUS <span class="string">&quot;$&#123;DAE_EXTRACT_DIR&#125; already exists, skip download &amp; extract&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span>()</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="variable">$&#123;DAE_FILENAME&#125;</span>)</span><br><span class="line">    <span class="keyword">file</span>(<span class="variable">$&#123;DAE_HASH_TYPE&#125;</span> <span class="variable">$&#123;DAE_FILENAME&#125;</span> _ACTUAL_CHKSUM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">NOT</span> (<span class="variable">$&#123;_EXPECT_HASH&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;_ACTUAL_CHKSUM&#125;</span>))</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;Expect $&#123;DAE_HASH_TYPE&#125;=$&#123;_EXPECT_HASH&#125;&quot;</span>)</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;Actual $&#123;DAE_HASH_TYPE&#125;=$&#123;_ACTUAL_CHKSUM&#125;&quot;</span>)</span><br><span class="line">      <span class="keyword">message</span>(WARNING <span class="string">&quot;File hash mismatch, remove &amp; retry ...&quot;</span>)</span><br><span class="line">      <span class="keyword">file</span>(<span class="keyword">REMOVE</span> <span class="variable">$&#123;DAE_FILENAME&#125;</span>)</span><br><span class="line">      download_file_with_hash(<span class="variable">$&#123;DAE_URL&#125;</span> <span class="variable">$&#123;DAE_FILENAME&#125;</span> <span class="variable">$&#123;DAE_HASH_TYPE&#125;</span></span><br><span class="line">                              <span class="variable">$&#123;_EXPECT_HASH&#125;</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;Using exists local file $&#123;DAE_FILENAME&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    download_file_with_hash(<span class="variable">$&#123;DAE_URL&#125;</span> <span class="variable">$&#123;DAE_FILENAME&#125;</span> <span class="variable">$&#123;DAE_HASH_TYPE&#125;</span></span><br><span class="line">                            <span class="variable">$&#123;_EXPECT_HASH&#125;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  extract_file(<span class="variable">$&#123;DAE_FILENAME&#125;</span> <span class="variable">$&#123;DAE_EXTRACT_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>于是，一个完整的文件下载解压函数就完成了，我们可以在项目中，这样使用自己实现的函数：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">download_and_extract(</span><br><span class="line">    URL https://example.com/<span class="number">1</span>.tar.gz</span><br><span class="line">    FILENAME /tmp/<span class="number">1</span>.tar.gz</span><br><span class="line">    HASH_TYPE SHA1</span><br><span class="line">    HASH xxxxxxxx</span><br><span class="line">    EXTRACT_DIR /tmp/example_dir)</span><br></pre></td></tr></table></figure><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/142">https://github.com/xizhibei/blog/issues/142</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/06/30/cmake-9-implement-download-extract-file/" target="_blank">https://blog.xizhibei.me/2020/06/30/cmake-9-implement-download-extract-file/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: cmake-9-implement-download-extract-file --&gt;

&lt;p&gt;今天补下之前在 &lt;a href=&quot;https://blog.xizhibei.me/2020/03/23/cmake-3-external-project</summary>
      
    
    
    
    
    <category term="CMake" scheme="https://blog.xizhibei.me/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>【CMake 系列】（八）交叉编译</title>
    <link href="https://blog.xizhibei.me/2020/06/15/cmake-8-cross-compiling/"/>
    <id>https://blog.xizhibei.me/2020/06/15/cmake-8-cross-compiling/</id>
    <published>2020-06-15T11:52:56.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: cmake-8-cross-compiling --><p>今天来说说，CMake 中稍许有些难度的部分：交叉编译。</p><p>虽说交叉编译有些难度，但是相对于其它的工具，CMake 的交叉编译支持还是很强大的，用一个 <code>CMAKE_TOOLCHAIN_FILE</code> 文件参数来制定交叉编译工具链就能解决大部分问题了。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面来说说一个例子，比如我们现在需要编译 <code>aarch64</code>（即 ARM architecture 64 位）上的可执行程序，或者库，我们就需要类似以下的工具链配置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_PROCESSOR aarch64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉编译器</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置搜索规则，这里需要重点注意，因为交叉编译所需要的依赖</span></span><br><span class="line"><span class="comment"># 一般不会放在系统目录下，而是会有专门的路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如你在编译第三方的库，无法修改源代码，不然不建议在这里修改 flags</span></span><br><span class="line"><span class="comment"># 设置编译 CXX flags，C flags 也是一样</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-march=armv8-a -fopenmp $&#123;CMAKE_CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他设置</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-D__ARM_NEON)</span><br><span class="line"><span class="keyword">add_definitions</span>(-DLINUX)</span><br></pre></td></tr></table></figure><p>然后，稍稍修改之前的四条命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_TOOLCHAIN_FILE=/path/to/toochain.cmake</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>到这里，是不是觉得很简单？下面来说说两个著名平台的交叉编译。</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>Android 有大名鼎鼎的 Android NDK，在比较新的版本中，其实已经有了 Toolchain 支持，所以在知道 Android NDK 的路径后，就可以直接使用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMAKE .. -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake</span><br></pre></td></tr></table></figure><p>当然，对应的，它还有几个参数还需要设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMAKE .. -DANDROID_NDK=<span class="variable">$ANDROID_NDK</span> \</span><br><span class="line">        -DCMAKE_TOOLCHAIN_FILE=<span class="variable">$ANDROID_NDK</span>/build/cmake/android.toolchain.cmake \</span><br><span class="line">        -DANDROID_ABI=<span class="string">&quot;arm64-v8a&quot;</span> \</span><br><span class="line">        -DANDROID_ARM_NEON=ON \</span><br><span class="line">        -DANDROID_TOOLCHAIN=clang \</span><br><span class="line">        -DANDROID_PLATFORM=android-19 \</span><br></pre></td></tr></table></figure><p>按照如上的配置之后就可以直接进行编译了。</p><p>当然，不出所料的话，如果你之前没有编译过，你大概率会遇到缺少库的问题，一般情况下，加上<code>target_link_libraries(myLib PUBLIC android log)</code> 即可。</p><p>其实，CMake 也原生支持 Android 的编译，不过我在使用的时候，还是倾向于使用 Android NDK 官方自己维护的 Toolchain，毕竟官方自己维护的动力也强一些。</p><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>其实 iOS 反而更简单，直接使用 CMake 提供的方式即可，不过，这里就需要在 Mac 上交叉编译了，基本上安装完 Xcode 就可以开始编译了。</p><p>这里还需要注意，苹果的封闭特性，导致了它的编译必须在它的体系内编译，比如这里的这里的 Generator 就需要改为 Xcode。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake .. \</span><br><span class="line">        -GXcode \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX=<span class="variable">$build_dir</span>/install \</span><br><span class="line">        -DCMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM=<span class="string">&quot;&lt;your-sign-key-id&gt;&quot;</span> \</span><br><span class="line">        -DCMAKE_SYSTEM_NAME=iOS \</span><br><span class="line">        <span class="string">&quot;-DCMAKE_OSX_ARCHITECTURES=armv7;arm64;i386;x86_64&quot;</span> \</span><br><span class="line">        -DCMAKE_OSX_DEPLOYMENT_TARGET=9.3 \</span><br><span class="line">        -DCMAKE_XCODE_ATTRIBUTE_ONLY_ACTIVE_ARCH=NO \</span><br><span class="line">        -DCMAKE_IOS_INSTALL_COMBINED=YES</span><br></pre></td></tr></table></figure><p>另外，在 CMakeLists.txt 中， 还需要修改编译对象的属性：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(IOS)</span><br><span class="line"><span class="keyword">set_target_properties</span>(</span><br><span class="line">  your-lib</span><br><span class="line">  PROPERTIES PUBLIC_HEADER <span class="string">&quot;$&#123;PROJECT_INCLUDE_FILES&#125;&quot;</span></span><br><span class="line">             MACOSX_FRAMEWORK_IDENTIFIER com.your-com-name.awesome-lib</span><br><span class="line">             VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span></span><br><span class="line">             SOVERSION <span class="string">&quot;$&#123;PROJECT_VERSION_MAJOR&#125;.0.0&quot;</span></span><br><span class="line">             FRAMEWORK <span class="keyword">TRUE</span></span><br><span class="line">             FRAMEWORK_VERSION C)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>这里的属性只是举例，你需要按照自己的要求修改。</p><h3 id="另外几个明显的坑"><a href="#另外几个明显的坑" class="headerlink" title="另外几个明显的坑"></a>另外几个明显的坑</h3><h4 id="不同目标程序的依赖完全不一样"><a href="#不同目标程序的依赖完全不一样" class="headerlink" title="不同目标程序的依赖完全不一样"></a>不同目标程序的依赖完全不一样</h4><p>你需要使用以下几个变量来控制编译步骤：</p><ol><li> CMAKE_CROSSCOMPILING：是否处于交叉编译环境；</li><li> ANDROID：安卓的编译环境；</li><li> APPLE：是否是苹果系列的编译环境；</li><li> IOS：是否是苹果手机环境；</li><li> UNIX：是否是 UNIX 或者 UNIX-like 的环境；</li><li> WIN32、MSVC：是否是 Windows</li></ol><p>另外，也需要在源代码中，区分不同目标平台的代码。</p><h4 id="编译程序无法直接在编译主机上运行"><a href="#编译程序无法直接在编译主机上运行" class="headerlink" title="编译程序无法直接在编译主机上运行"></a>编译程序无法直接在编译主机上运行</h4><p>假如你的程序依赖编译后的可执行文件来进行操作，那么这里就会遇到障碍了，不过方案也是有的，比如分开编译过程，将对应平台的可执行文件编译好放在专门的地方，在后续的编译步骤中直接调用。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>CMake 提供的交叉编译方式在我看来是非常简单以及优雅的，只需要切换不同的 Toolchain 文件便可以轻松将你的代码移植到其他平台。</p><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/141">https://github.com/xizhibei/blog/issues/141</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/06/15/cmake-8-cross-compiling/" target="_blank">https://blog.xizhibei.me/2020/06/15/cmake-8-cross-compiling/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: cmake-8-cross-compiling --&gt;

&lt;p&gt;今天来说说，CMake 中稍许有些难度的部分：交叉编译。&lt;/p&gt;
&lt;p&gt;虽说交叉编译有些难度，但是相对于其它的工具，CMake 的交叉编译支持还是很强大的，用一个 &lt;code&gt;CMAKE</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://blog.xizhibei.me/tags/C-C/"/>
    
    <category term="CMake" scheme="https://blog.xizhibei.me/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>【CMake 系列】（七）常用变量、函数以及模块</title>
    <link href="https://blog.xizhibei.me/2020/06/02/cmake-7-common-var-func-and-modules/"/>
    <id>https://blog.xizhibei.me/2020/06/02/cmake-7-common-var-func-and-modules/</id>
    <published>2020-06-02T10:52:11.000Z</published>
    <updated>2021-05-01T15:35:48.465Z</updated>
    
    <content type="html"><![CDATA[<!-- en_title: cmake-7-common-var-func-and-modules --><p>用了 CMake 较长一段时间后，在笔记本里面记录了不少知识，这些知识其实应该放在这个系列文章的开始来讲，因为算是很入门的部分，这里就简单总结下。</p><h3 id="配置期间"><a href="#配置期间" class="headerlink" title="配置期间"></a>配置期间</h3><h4 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/include/config.h.in&quot;</span></span><br><span class="line">               <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/include/config.h&quot;</span>)</span><br></pre></td></tr></table></figure><p>比如，你可以将 cmake 中，project 命令中设置的版本，通过这个方式传递给程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.h.in</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_VERSION_MAJOR @PROJECT_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_VERSION_MINOR @PROJECT_VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_VERSION_PATCH @PROJECT_VERSION_PATCH@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_VERSION_TWEAK @PROJECT_VERSION_TWEAK@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_VERSION <span class="meta-string">&quot;@PROJECT_VERSION@&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过两个 <code>@</code> 符号，就可以将 cmake 中的变量传递到我们所需要编译的程序中。</p><h4 id="防手贱"><a href="#防手贱" class="headerlink" title="防手贱"></a>防手贱</h4><p>禁止在源目录编译以及修改，可以在不小心在当前目录编译的时候，报错退出，防止污染源代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_DISABLE_IN_SOURCE_BUILD <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_DISABLE_SOURCE_CHANGES <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><h4 id="第三方库的查找"><a href="#第三方库的查找" class="headerlink" title="第三方库的查找"></a>第三方库的查找</h4><p>这里需要用到 <code>CMAKE_FIND_ROOT_PATH</code> 以及 <code>CMAKE_PREFIX_PATH</code>，因为 CMake 回去系统默认的地方查找对应的库，如果你需要用到放在其他地方的库，可以在这个变量中添加。</p><p>另外，对于单个库，也可以使用这两个变量：</p><ul><li>  <code>&lt;PackageName&gt;_ROOT</code>：用来指定头文件以及库、可执行文件的路径；</li><li>  <code>&lt;PackageName&gt;_DIR</code>：用来指定库的 CMake 文件路径；</li></ul><h3 id="编译期间"><a href="#编译期间" class="headerlink" title="编译期间"></a>编译期间</h3><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>假如在系统中存在多种编译器或者版本，可以通过设置以下两个变量来设置 C 以及 C++ 的编译器：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_C_COMPILER=/path/to/gcc</span><br><span class="line">CMAKE_CXX_COMPILER=/path/to/g++</span><br></pre></td></tr></table></figure><h4 id="FLAGS"><a href="#FLAGS" class="headerlink" title="FLAGS"></a>FLAGS</h4><p>如果需要自定义编译配置，还可以设置以下的变量，大部分情况下，你都不需要配置，CMake 会根据环境以及其它变量自动配置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_C_FALGS=</span><br><span class="line">CMAKE_CXX_FALGS=-fopenmp</span><br></pre></td></tr></table></figure><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>如果你说需要上面的 <code>FALGS</code> 来配置 <code>-std=c++17</code>，那也不需要，你可以设置其他的变量来达到这个目的，比如全局的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>以及更被建议的局部做法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(myTarget lib.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(myTarget PROPERTIES</span><br><span class="line">    CXX_STANDARD <span class="number">17</span></span><br><span class="line">    CXX_STANDARD_REQUIRED YES</span><br><span class="line">    CXX_EXTENSIONS NO</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>另外，如果想要 <code>-fPIC</code>，也有专门的变量：<code>CMAKE_POSITION_INDEPENDENT_CODE</code>，当然，这个也建议在局部做：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(myTarget PROPERTIES POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><h4 id="预处理定义"><a href="#预处理定义" class="headerlink" title="预处理定义"></a>预处理定义</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_definitions</span>(-DTEST) <span class="comment"># 全局</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(-DTEST) <span class="comment"># 局部</span></span><br></pre></td></tr></table></figure><h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><p>编译类别 <code>CMAKE_BUILD_TYPE</code> 我们常用的也就 <code>Release</code> 与 <code>Debug</code>，由于编译环境的不同，也会对这个值进行限制，具体需要参考 <code>CMAKE_CONFIGURATION_TYPES</code>，比如 还可以有 <code>RelWithDebInfo</code> 以及 <code>MinSizeRel</code>。</p><p>这个变量，会决定编译是否优化以及带上调试信息，千万不要给你们公司的私有程序以 Debug 模型发布出去了，原因？一个是代码没优化，性能会比较差，另外就是会泄露源码。</p><h4 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h4><p>需要用到 <code>BUILD_SHARED_LIBS</code> 这个变量，常常被用到 <code>option</code> 里面提供给用户进行配置，这个变量控制的是 <code>add_libary(myLib ...)</code> 最后生成的类别。</p><p>或许你会奇怪为什么没有 <code>BUILD_STATIC_LIBS</code>，其实默认就是 <code>static</code>，也就是相当于 <code>BUILD_SHARED_LIBS=OFF</code>。</p><p>另外，还有个小技巧，如果你需要同时编译动态库与静态库，可以用类似以下的方式来做到：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_libary(myLib STATIC lib.cpp)</span><br><span class="line"></span><br><span class="line">add_libary(mySharedLib SHARED lib.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(mySharedLib PROPERTIES OUTPUT_NAME myLib)</span><br></pre></td></tr></table></figure><h3 id="几个有用的模块"><a href="#几个有用的模块" class="headerlink" title="几个有用的模块"></a>几个有用的模块</h3><p>ExternalProject 就不用多说了，前面在 <a href="https://blog.xizhibei.me/2020/03/23/cmake-3-external-project-practise/">【CMake 系列】（三）ExternalProject 实践</a> 专门介绍过。</p><p>注意：这几个模块需要通过 <code>include</code> 来引入后才能使用。</p><h4 id="CMakePrintHelpers"><a href="#CMakePrintHelpers" class="headerlink" title="CMakePrintHelpers"></a>CMakePrintHelpers</h4><p>非常适合用来调试，<code>cmake_print_variables</code> 帮助你打印出变量的值以及 <code>cmake_print_properties</code> 可以打印出 target 中的一些属性。</p><p>下面就是一个打印出 <code>include</code> 路径的例子：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake_print_properties(TARGETS foo bar PROPERTIES</span><br><span class="line">                       LOCATION INTERFACE_INCLUDE_DIRECTORIES)</span><br></pre></td></tr></table></figure><h4 id="WriteCompilerDetectionHeader"><a href="#WriteCompilerDetectionHeader" class="headerlink" title="WriteCompilerDetectionHeader"></a>WriteCompilerDetectionHeader</h4><p>有些时候，为了写跨平台的代码，我们需要判别编译器是否支持一些特性，CMake 就提供了这个模块，它可以帮助你生成一个预定义头文件，帮你把一些编译器支持的特性全部罗列出来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write_compiler_detection_header(</span><br><span class="line">  <span class="keyword">FILE</span> <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/include/foo_compiler_detection.h&quot;</span></span><br><span class="line">  PREFIX MY_PREFIX</span><br><span class="line">  COMPILERS GNU Clang AppleClang MSVC</span><br><span class="line">  FEATURES cxx_constexpr)</span><br></pre></td></tr></table></figure><p>这里的编译特性还可以有：</p><ul><li>  cxx_constexpr</li><li>  cxx_deleted_functions</li><li>  cxx_extern_templates</li><li>  cxx_variadic_templates</li><li>  cxx_noexcept</li><li>  cxx_final</li><li>  cxx_override</li></ul><h4 id="FeatureSummary"><a href="#FeatureSummary" class="headerlink" title="FeatureSummary"></a>FeatureSummary</h4><p>这个模块适合在项目初始化完成的最后，打印出一些总结性信息：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feature_summary(WHAT ALL)</span><br></pre></td></tr></table></figure><p>然后，你还可以给这个总结添加更多说明：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set_package_properties(LibXml2 PROPERTIES</span><br><span class="line">                       TYPE RECOMMENDED</span><br><span class="line">                       PURPOSE <span class="string">&quot;Enables HTML-import in MyWordProcessor&quot;</span>)</span><br><span class="line">                       </span><br><span class="line"><span class="keyword">option</span>(WITH_FOO <span class="string">&quot;Help for foo&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line">add_feature_info(Foo WITH_FOO <span class="string">&quot;The Foo feature provides very cool stuff.&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样，你就可以看到更多的总结信息了。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这个就太简单了，但是又非常常见，怕初学者不清楚，这里就提示下：</p><p>直接设置 <code>CMAKE_INSTALL_PREFIX</code> 即可，最后执行安装命令的时候，会将对应的文件安装到制定的目录。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>上面简单罗列了我们团队项目中常用的，也是经过我挑选之后的，毕竟那么多的特性，不可能在这一篇文章中全部列出，详细的还是需要看 CMake 官方文档。另外，文中大部分的例子也是来自于 CMake 官方文档。</p><hr><p>首发于 Github issues: <a href="https://github.com/xizhibei/blog/issues/140">https://github.com/xizhibei/blog/issues/140</a> ，欢迎 Star 以及 Watch</p><b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b><br/><b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b><br/><b>原链接：<a href="https://blog.xizhibei.me/2020/06/02/cmake-7-common-var-func-and-modules/" target="_blank">https://blog.xizhibei.me/2020/06/02/cmake-7-common-var-func-and-modules/</a></b><br/><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- en_title: cmake-7-common-var-func-and-modules --&gt;

&lt;p&gt;用了 CMake 较长一段时间后，在笔记本里面记录了不少知识，这些知识其实应该放在这个系列文章的开始来讲，因为算是很入门的部分，这里就简单总结下。&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    
    <category term="C/C++" scheme="https://blog.xizhibei.me/tags/C-C/"/>
    
    <category term="CMake" scheme="https://blog.xizhibei.me/tags/CMake/"/>
    
  </entry>
  
</feed>
