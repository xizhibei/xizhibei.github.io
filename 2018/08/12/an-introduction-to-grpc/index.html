<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="技术分享 | Node.js | kubernetes | ansible | Docker | DevOps | 思维与认知"><title>gRPC 的介绍以及实践 | 须臾之学</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91452326-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">gRPC 的介绍以及实践</h1><a id="logo" href="/.">须臾之学</a><p class="description">别瞎想，多走走，多看书</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">gRPC 的介绍以及实践</h1><div class="post-meta">2018-08-12<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><!-- en_title: an-introduction-to-grpc -->

<p>gRPC 是个通用、高性能的开源 RPC 框架。它可以高效地连接单个或多个数据中心的服务。另外也可以支持可插拔的负载均衡、追踪、健康检查以及认证。最后，它也能应用于分布式计算的最后一公里来连接各种设备、手机应用、浏览器与后端服务。[1]</p>
<p>这里可以留意下最后一句话，这句话的意思是：你可以使用 gRPC 来取代现有的 RESTful 接口。事实上，已经有很多案例这么做了：以关键词『gRPC iOS』或者『gRPC Android』去 Google 一下就会发现很多案例。</p>
<a id="more"></a>

<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>它所依赖的东西，有两个：HTTP2 以及 Protocol buffer（当然了，其它协议也是支持的，比如 JSON，但是默认推荐的就是 PB ），较于 JSON on HTTP/HTTPS 相当于 PB on HTTP2。</p>
<p>照例，开课前必须得先复习这两个基础知识。</p>
<h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><p>先介绍下 HTTP2，它是针对 1.x 是替代，而不是重写，它的方法、状态码、语义等都与 1.x 保持一致，专注于性能的提升，最大的目的是客户端与服务端只用一个连接[2]；</p>
<p>它提供了如多路复用、双向流、服务器推送、请求优先级、首部压缩等等机制来达到节省带宽、降低 TCP 连接开销的目的，简单来说，HTTP2 采用的协议能大大提升通信效率。</p>
<p>这里只是简单略过，之后有时间会展开再划一划重点。</p>
<h4 id="Protocol-buffer"><a href="#Protocol-buffer" class="headerlink" title="Protocol buffer"></a>Protocol buffer</h4><p>它是 Google 旗下的一款平台无关，语言无关，可扩展的序列化结构数据格式。同时也是 IDL(Interface Definition Language)，其实可以将它与 JSON、XML 对比来说，其实它就是一种序列化的协议，通过强制定义数据类型，它的效率其实是超过 json 的，因为不需要像 json 那样动态解析类型。</p>
<p>这一点很重要，gRPC 以此为基础，也就意味着客户端与服务端必须都使用同一份或者互相兼容的 proto 文件。</p>
<p>对应的好处也很明显，大家不用维护冗长的 RESTful API 文档了，直接将加过注释的 proto 文件扔给对方就行了。千万不要小看这一点，多少问题就是因为文档不清楚导致的，与其费劲心思让工程师维护一份有可能两边不一致的 API 文档，还不如强制一份 proto 文件，减少出问题的可能性，从这点说，proto 文件其实就是一个强规范的以及方便的文档。</p>
<p>可能你会觉得 PB 强类型也会显得不灵活，两边的通信层可能会需要加上很多转换逻辑，但 gRPC 支持根据 proto 文件生成客户端或服务端，等于帮我们省去了很多的编写通用代码时间。</p>
<h3 id="gRPC-的数据交互方式"><a href="#gRPC-的数据交互方式" class="headerlink" title="gRPC 的数据交互方式"></a>gRPC 的数据交互方式</h3><p>在 gRPC 中，是支持流的，也就是一连串的数据，这其实也是靠 HTTP2 的特性。</p>
<ul>
<li>  Unary RPCs，一次请求，一次返回，没有流，这是最常用的方式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  Server streaming RPCs，客户端发送单次请求，服务端会返回一连串的数据，比如服务端向客户端推送站内即时消息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  Client streaming RPCs，客户端会发送一连串的数据到服务端，服务端返回单次数据，比如发送实时日志：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  Bidirectional streaming RPCs，双向流，两边各自会发送一连串的数据，比如实时语音通话以及一些游戏场景中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns (stream HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="Golang-中如何使用"><a href="#Golang-中如何使用" class="headerlink" title="Golang 中如何使用"></a>Golang 中如何使用</h4><p><a target="_blank" rel="noopener" href="https://grpc.io/docs/quickstart/go.html">官方的例子</a>中，是根据 proto 文件生成，这个工具是必须得有的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/&#123;protoc-gen-go,proto&#125;</span><br><span class="line">protoc service.proto --go_out=plugins=grpc:.</span><br></pre></td></tr></table></figure>
<p>与 <a href="https://blog.xizhibei.me/2018/05/27/swiss-army-knife-for-golang-microsevice-go-kit/">go-kit</a> 配合起来使用是极佳的，因为同时还能支持其它协议。</p>
<p>以下两个项目可以着重看看：</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a>： 一些现成的中间件，认证、日志、分布式追踪跟重试等等；</li>
<li>  <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>：一个 protoc 的插件，可以将 gRPC 接口转换为对外暴露 RESTful API 的工具，同时还能生成 swagger 文档；</li>
</ul>
<h4 id="Node-js-中如何使用"><a href="#Node-js-中如何使用" class="headerlink" title="Node.js 中如何使用"></a>Node.js 中如何使用</h4><p>由于是动态语言，所以直接加载即可，还是参考<a target="_blank" rel="noopener" href="https://grpc.io/docs/quickstart/node.html">官方的例子</a>。</p>
<p>当用在客户端的时候，由于往往使用的是 Unary Call，也就是没有流存在，这时候 Node.js 生成的是 callback 风格的，显然已经过时了，可以参考如下代码的思路做一次 Promise 封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Service = grpc.load(protoPath)[packageName][serviceName];</span><br><span class="line"><span class="keyword">const</span> methods = _.keys(Service.prototype).filter(<span class="function"><span class="params">m</span> =&gt;</span> _.isFunction(Service.prototype[m]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _client = <span class="keyword">new</span> Service(host, grpcCredentials, grpcOpts)</span><br><span class="line">_client = <span class="built_in">Promise</span>.promisifyAll(client);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = &#123;&#125;</span><br><span class="line">_.each(methods, <span class="function"><span class="params">m</span> =&gt;</span> client[m] = _client[<span class="string">`<span class="subst">$&#123;m&#125;</span>Async`</span>].bind(_client));</span><br></pre></td></tr></table></figure>
<p>另外，安装 grpc 的 npm 包的时候，会从被墙的 Google storage 取数据，因此多半会失败，fallback 到本地编译，显然会拖慢安装速度，因此建议搭建代理来解决。</p>
<p>在 ~/.npmrc 下添加如下配置即可（淘宝的那个 grpc 镜像不行，跟这个包需要的地址无法映射）。</p>
<pre><code>grpc_node_binary_host_mirror=http://your-proxy-server
</code></pre>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li><p>集中式负载均衡：<br>  由于是基于 HTTP2，于是靠外部负载均衡都是可以的，而且是相对简单的，比如 Nginx 以及 traefik，都实现了 HTTP2 的负载均衡。</p>
</li>
<li><p>进程内负载均衡：<br>  进程内，也就是客户端的进程内负载均衡也是可以的，而且由于少了一层外部负载均衡，性能也会有所提升。同时，客户端负载均衡需要进行动态服务发现，即将服务解析为每个服务端的地址，需要依靠外部服务发现，比如 etcd、consul 等，而如果是在 k8s 中使用，可以使用 DNS 的 srv 记录实现负载均衡，另外，<a target="_blank" rel="noopener" href="https://github.com/grpc/proposal/blob/master/A5-grpclb-in-dns.md">这是 gRPC 是原生支持的</a>。</p>
</li>
<li><p>独立进程负载均衡：<br>  其实也属于客户端，只不过这样可以将服务发现以及负载均衡相关的逻辑抽出来，变为本地调用，支持任何语言实现的客户端，同时也是简化了客户端的实现（对了，其实就是 Service Mesh 的核心思想）。</p>
</li>
</ul>
<h4 id="DNS-服务发现负载均衡"><a href="#DNS-服务发现负载均衡" class="headerlink" title="DNS 服务发现负载均衡"></a>DNS 服务发现负载均衡</h4><p>如果没有听说过，简单说下，就是通过 k8s 的 Headless service （就是没有 Cluster IP 的 service）来实现。</p>
<p>假如你有如下的 service：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 重点</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">1234</span> </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>然后在一个有 dig 工具的 docker container 中运行以下命令后:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig srv  _http._tcp.foo.bar.svc.cluster.local</span><br></pre></td></tr></table></figure>
<p>会发现类似下面的输出（部分）：</p>
<pre><code>;; QUESTION SECTION:
;_http._tcp.foo.bar.svc.cluster.local. IN SRV

;; ANSWER SECTION:
_http._tcp.foo.bar.svc.cluster.local. 30 IN SRV 10 33 1234 3166346562643838.foo.bar.svc.cluster.local.
_http._tcp.foo.bar.svc.cluster.local. 30 IN SRV 10 33 1234 6134356136303531.foo.bar.svc.cluster.local.
_http._tcp.foo.bar.svc.cluster.local. 30 IN SRV 10 33 1234 3866623563306661.foo.bar.svc.cluster.local.

;; ADDITIONAL SECTION:
3166346562643838.foo.bar.svc.cluster.local. 30 IN A 10.233.67.245
6134356136303531.foo.bar.svc.cluster.local. 30 IN A 10.233.68.21
3866623563306661.foo.bar.svc.cluster.local. 30 IN A 10.233.71.141
</code></pre>
<p>可以发现这个 foo 的服务有 3 个 pod，给出了分别对应的 IP 以及对应端口是 1234。于是通过将服务地址配置为服务端地址后，就可以很简单地实现负载均衡了。</p>
<p>另外，很遗憾的，Node.js 的 grpc 底层用的 C++ addon 模块虽然有负载均衡能力，但是<a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!topic/grpc-io/Uaq3K3TDDjU">还没有在 node 层面实现相关的胶合代码</a>，但是 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go">grpc-go</a> 是实现的了。</p>
<h4 id="Health-check"><a href="#Health-check" class="headerlink" title="Health check"></a>Health check</h4><p>健康检查建议要实现，尤其是依靠客户端负载均衡的，而且官方也已经定了<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">健康检查的协议</a></p>
<p>如果是在依赖于服务发现的负载均衡中，健康检查最好是让外部服务发现去做，比如 consul 就支持 <a target="_blank" rel="noopener" href="https://www.consul.io/api/agent/check.html#grpc">gRPC 的健康检查协议</a>。这样做的话，可以避免客户端太多的情况下，每个客户端都需要做健康检查，发送太多健康检查请求，挤占带宽以及影响服务端性能。</p>
<p>最后，是不是被这些要做的事情给搞头大了？没事，请允许我在这插个无耻的广告：我将 Node.js 的 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-node/blob/master/packages/grpc-native-core">grpc</a> 做了个封装，实现了 Unary call 的 Promise 化，以及服务发现、负载均衡、健康检查、断路器等。正在开发中，欢迎提意见，详情请看：<a target="_blank" rel="noopener" href="https://github.com/xizhibei/grpc-helper">xizhibei/grpc-helper</a>。</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ol>
<li> <a target="_blank" rel="noopener" href="https://grpc.io/about/">gRPC</a></li>
<li> <a target="_blank" rel="noopener" href="https://http2.github.io/">HTTP2</a></li>
<li> <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a></li>
</ol>
<hr>
<p>首发于 Github issues: <a target="_blank" rel="noopener" href="https://github.com/xizhibei/blog/issues/84">https://github.com/xizhibei/blog/issues/84</a> ，欢迎 Star 以及 Watch</p>
<b>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">署名-非商业性使用-相同方式共享（BY-NC-SA）</a>进行许可</b>
<br/>
<b>作者：<a href="https://blog.xizhibei.me/about/" target="_blank">习之北 (@xizhibei)</a></b>
<br/>
<b>原链接：<a href="https://blog.xizhibei.me/2018/08/12/an-introduction-to-grpc/" target="_blank">https://blog.xizhibei.me/2018/08/12/an-introduction-to-grpc/</a></b>
<br/>

<hr>
</div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://blog.xizhibei.me/2018/08/12/an-introduction-to-grpc/" data-id="cko5wqfn1000h36shhgq5a0ok" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIklEQVR42u3aS3LDIBAFQN//0s4BnMjvAUqVoLVyxYqgtRgzn9crvt6XV3Ln5z3Xq7zuuDAwMB7LSLaYM1rSJ2xwXQwMjAMY+aOvg+Nfm7j+S/Ltlz1jYGBgLN3uzLoYGBgYY8e1dhN5EMfAwMBok9iZ0thYee6WXBwDA+OBjHwT///5lv4GBgbGoxjv8poporXJcLErDAyMrRl5gGsbkG15Lkmqv+wHAwPjAEYyqpWPc+WpZtIwiA6LGBgYmzLy5fMyWU4dG9345X4MDIwDGPlGxxLUduC1bjxgYGAcxshbmPkJrX01U9MiGBgYWzPareQjFHliPPY0DAyMvRltSzJJKWcGv2ZGQDAwME5jjKWgq/63LrdhYGBszbgOf8t6pMG7bJPY4hcDAwPj4Yy14XL+wLf49WFgYGzBWBVq28NlchWvCQMD4wBGXkoba0PmDdG8aYqBgXEOY+wRY8MWSWDNqVFXFgMDYzvGTNmrLaW1ox71mBoGBsZ2jDxlzVPcdswiCc1fMBgYGEcykqPeDL49MkYzIxgYGAcw2sXuSHfrEhsGBsbWjPm24vygxoL8GwMDY2vGWIhsm53toFhyGB0M9xgYGI9ltIWtPIDWJbOh1BcDA+Mcxkzgy5sEM0nsFyQGBgZG2WJc1RbNXxMGBgZGEi6vl7zjnmUBFwMD4yGMfIQrP/bNp8e35OIYGBgPZOSpYx6gZ6Y/xsbUMDAwNmX8ANbck2G4Y2mwAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/Golang/"><i class="fa fa-tag"></i>Golang</a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><i class="fa fa-tag"></i>基础知识</a><a href="/tags/Node-js/"><i class="fa fa-tag"></i>Node.js</a><a href="/tags/gRPC/"><i class="fa fa-tag"></i>gRPC</a></div><div class="post-nav"><a class="pre" href="/2018/08/26/better-apidoc-process-for-your-team/">你的团队需要更好的 API 文档流程</a><a class="next" href="/2018/07/29/https-and-ssl-tls-review/">划一划 HTTPS 以及 SSL/TLS 的重要知识点</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.xizhibei.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%96%87%E6%A1%A3/" style="font-size: 15px;">文档</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/%E8%81%8C%E5%9C%BA/" style="font-size: 15px;">职场</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E9%89%B4%E4%B9%A6/" style="font-size: 15px;">鉴书</a> <a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 15px;">旅行</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 15px;">生活</a> <a href="/tags/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/" style="font-size: 15px;">视频直播</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 15px;">监控</a> <a href="/tags/%E9%87%8D%E6%9E%84/" style="font-size: 15px;">重构</a> <a href="/tags/DevOps/" style="font-size: 15px;">DevOps</a> <a href="/tags/ELK/" style="font-size: 15px;">ELK</a> <a href="/tags/Elasticsearch/" style="font-size: 15px;">Elasticsearch</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">基础知识</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/TypeScript/" style="font-size: 15px;">TypeScript</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" style="font-size: 15px;">年度总结</a> <a href="/tags/RabbitMQ/" style="font-size: 15px;">RabbitMQ</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 15px;">架构</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">系统设计</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/" style="font-size: 15px;">工作方法</a> <a href="/tags/%E4%BC%81%E4%B8%9A%E6%96%87%E5%8C%96/" style="font-size: 15px;">企业文化</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/ansible/" style="font-size: 15px;">ansible</a> <a href="/tags/Gitlab/" style="font-size: 15px;">Gitlab</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">测试</a> <a href="/tags/%E6%B2%9F%E9%80%9A/" style="font-size: 15px;">沟通</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/" style="font-size: 15px;">系统思考</a> <a href="/tags/Prometheus/" style="font-size: 15px;">Prometheus</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 15px;">微服务</a> <a href="/tags/%E5%88%9B%E4%B8%9A/" style="font-size: 15px;">创业</a> <a href="/tags/C-x2F-C/" style="font-size: 15px;">C&#x2F;C++</a> <a href="/tags/Angular/" style="font-size: 15px;">Angular</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/%E4%B8%9A%E5%8A%A1/" style="font-size: 15px;">业务</a> <a href="/tags/Helm/" style="font-size: 15px;">Helm</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 15px;">配置</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 15px;">管理</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 15px;">安全</a> <a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/" style="font-size: 15px;">反爬虫</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E6%8B%9B%E8%81%98/" style="font-size: 15px;">招聘</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 15px;">读书</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/01/linux-time-hwclock/">Linux 时间之 hwclock</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/28/netflix-no-rules-rules/">不拘一格的网飞</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/22/engineer-s-tsundere/">工程师的傲骄</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/12/cmake-shared-lib-absolute-path-problem/">CMake 动态链接库绝对路径问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/12/a-brief-intro-of-rpath/">RPATH 简介以及 CMake 中的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/03/https-two-way-authentication-with-certificates/">HTTPS 双向证书认证</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/poor-mans-profiler/">穷人的程序性能分析器</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/01/summary-of-2020/">2020 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/20/a-simple-implementation-of-rtsp-server/">RTSP 服务器的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/21/disk-cache-start-with-a-file-missing-problem/">磁盘缓存：从一次文件丢失问题说起</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">须臾之学.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>